#define _USE_MATH_DEFINES
#define _CRT_SECURE_NO_WARNINGS

#include <windows.h>
#include <vector>
#include <stack>
#include <cmath>
#include <fstream>
#include <string>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <commdlg.h>
#include <cstdio>
using namespace std;
// Forward declarations
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void RegisterMyClass(HINSTANCE hInstance);
void CreateMainMenu(HWND hwnd);

// Global variables
RECT clientRect;

// Backing buffer (off-screen bitmap) variables
HDC     hMemDC = NULL;
HBITMAP hBitmap = NULL;
HBITMAP hOldBitmap = NULL;

// Color variables
COLORREF drawColor = RGB(0, 0, 0);
COLORREF fillColor = RGB(255, 0, 0);
COLORREF bgColor = RGB(255, 255, 255);

// Enums for drawing modes and algorithms
enum DrawingMode {
    MODE_NONE,
    MODE_DRAW_LINE,
    MODE_DRAW_CIRCLE,
    MODE_DRAW_ELLIPSE,
    MODE_FLOOD_FILL,
    MODE_CARDINAL_SPLINE,
    MODE_CLIPPING
};

enum LineAlgoType {
    LINE_ALGO_BRESENHAM,
    LINE_ALGO_DDA,
    LINE_ALGO_MIDPOINT,
    LINE_ALGO_PARAMETRIC
};

enum CircleAlgoType {
    CIRCLE_ALGO_DIRECT,
    CIRCLE_ALGO_POLAR,
    CIRCLE_ALGO_ITERATIVE_POLAR,
    CIRCLE_ALGO_MIDPOINT,
    CIRCLE_ALGO_MODIFIED_MIDPOINT
};

enum EllipseAlgoType {
    ELLIPSE_ALGO_DIRECT,
    ELLIPSE_ALGO_POLAR,
    ELLIPSE_ALGO_MIDPOINT
};

enum FillAlgoType {
    FILL_ALGO_RECURSIVE,
    FILL_ALGO_NON_RECURSIVE
};

enum ClippingMode {
    CLIPPING_NONE,
    CLIPPING_RECTANGLE,
    CLIPPING_SQUARE
};

enum ClippingShapeType {
    CLIP_POINT,
    CLIP_LINE,
    CLIP_POLYGON
};

// Global state variables
DrawingMode drawingMode = MODE_NONE;
LineAlgoType lineAlgorithm = LINE_ALGO_BRESENHAM;
CircleAlgoType circleAlgorithm = CIRCLE_ALGO_MIDPOINT;
EllipseAlgoType ellipseAlgorithm = ELLIPSE_ALGO_MIDPOINT;
FillAlgoType fillAlgorithm = FILL_ALGO_NON_RECURSIVE;
ClippingMode clippingMode = CLIPPING_NONE;
ClippingShapeType clippingShapeType = CLIP_POINT;

bool isDrawing = false;
POINT startPoint;
POINT endPoint;
std::vector<POINT> controlPoints;
std::vector<POINT> clippingPoints;
RECT clippingRect = { 200, 150, 600, 450 };

// Structure to hold information about a drawn shape
enum ShapeType {
    SHAPE_LINE,
    SHAPE_CIRCLE,
    SHAPE_ELLIPSE,
    SHAPE_FILLED_REGION,
    SHAPE_CARDINAL_SPLINE,
    SHAPE_CLIPPED
};

struct LineShape {
    POINT p1, p2;
    COLORREF color;
    LineAlgoType algo;
};

struct CircleShape {
    POINT center;
    int radius;
    COLORREF color;
    CircleAlgoType algo;
};

struct EllipseShape {
    POINT center;
    int a, b;
    COLORREF color;
    EllipseAlgoType algo;
};

struct FilledRegionShape {
    POINT seedPoint;
    COLORREF fillColor;
    COLORREF targetColor;
    COLORREF boundaryColor;
    FillAlgoType algo;
};

struct SplineShape {
    std::vector<POINT> points;
    double tension;
    COLORREF color;
};

struct ClippedShape {
    std::vector<POINT> points;
    COLORREF color;
    ClippingShapeType type;
};

struct DrawnShape {
    ShapeType type;
    union {
        LineShape line;
        CircleShape circle;
        EllipseShape ellipse;
        FilledRegionShape filledRegion;
        SplineShape spline;
        ClippedShape clipped;
    };

    DrawnShape() : type(SHAPE_LINE) {}

    DrawnShape(const DrawnShape& other) : type(other.type) {
        switch (type) {
        case SHAPE_LINE:
            line = other.line;
            break;
        case SHAPE_CIRCLE:
            circle = other.circle;
            break;
        case SHAPE_ELLIPSE:
            ellipse = other.ellipse;
            break;
        case SHAPE_FILLED_REGION:
            filledRegion = other.filledRegion;
            break;
        case SHAPE_CARDINAL_SPLINE:
            new (&spline) SplineShape();
            spline.points = other.spline.points;
            spline.tension = other.spline.tension;
            spline.color = other.spline.color;
            break;
        case SHAPE_CLIPPED:
            new (&clipped) ClippedShape();
            clipped.points = other.clipped.points;
            clipped.color = other.clipped.color;
            clipped.type = other.clipped.type;
            break;
        }
    }

    DrawnShape& operator=(const DrawnShape& other) {
        if (this != &other) {
            if (type == SHAPE_CARDINAL_SPLINE) {
                spline.~SplineShape();
            }
            else if (type == SHAPE_CLIPPED) {
                clipped.~ClippedShape();
            }

            type = other.type;
            switch (type) {
            case SHAPE_LINE:
                line = other.line;
                break;
            case SHAPE_CIRCLE:
                circle = other.circle;
                break;
            case SHAPE_ELLIPSE:
                ellipse = other.ellipse;
                break;
            case SHAPE_FILLED_REGION:
                filledRegion = other.filledRegion;
                break;
            case SHAPE_CARDINAL_SPLINE:
                new (&spline) SplineShape();
                spline.points = other.spline.points;
                spline.tension = other.spline.tension;
                spline.color = other.spline.color;
                break;
            case SHAPE_CLIPPED:
                new (&clipped) ClippedShape();
                clipped.points = other.clipped.points;
                clipped.color = other.clipped.color;
                clipped.type = other.clipped.type;
                break;
            }
        }
        return *this;
    }

    ~DrawnShape() {
        if (type == SHAPE_CARDINAL_SPLINE) {
            spline.~SplineShape();
        }
        else if (type == SHAPE_CLIPPED) {
            clipped.~ClippedShape();
        }
    }
};

std::vector<DrawnShape> drawnShapes;

// Helper Functions
void SetPixelSafe(HDC targetDC, int x, int y, COLORREF color) {
    if (x >= 0 && x < clientRect.right && y >= 0 && y < clientRect.bottom) {
        SetPixel(targetDC, x, y, color);
    }
}

int Round(double x) {
    return static_cast<int>(x + 0.5);
}

// Drawing Functions
void DrawLine(HDC targetDC, int x0, int y0, int x1, int y1, COLORREF color) {
    int dx = abs(x1 - x0), dy = abs(y1 - y0);
    int sx = (x0 < x1) ? 1 : -1;
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx - dy;

    while (true) {
        SetPixelSafe(targetDC, x0, y0, color);
        if (x0 == x1 && y0 == y1) break;
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}

void DrawDDALine(HDC targetDC, POINT p1, POINT p2, COLORREF color) {
    int x1 = p1.x, y1 = p1.y;
    int x2 = p2.x, y2 = p2.y;

    if (x1 > x2) {
        std::swap(x1, x2);
        std::swap(y1, y2);
    }

    int dx = x2 - x1;
    int dy = y2 - y1;

    if (abs(dx) >= abs(dy)) {
        double m = (dx == 0) ? 0.0 : (double)dy / dx;
        double y = y1;
        int x = x1;
        while (x <= x2) {
            SetPixelSafe(targetDC, x, Round(y), color);
            y += m;
            x++;
        }
    }
    else {
        if (y1 > y2) {
            std::swap(x1, x2);
            std::swap(y1, y2);
        }
        double mi = (dy == 0) ? 0.0 : (double)dx / dy;
        double x = x1;
        int y = y1;
        while (y <= y2) {
            SetPixelSafe(targetDC, Round(x), y, color);
            x += mi;
            y++;
        }
    }
}

void DrawMidpointLine(HDC targetDC, POINT p1, POINT p2, COLORREF color) {
    int x1 = p1.x, y1 = p1.y;
    int x2 = p2.x, y2 = p2.y;
    int dx = x2 - x1;
    int dy = y2 - y1;

    if (abs(dy) <= abs(dx)) {
        if (x1 > x2) {
            std::swap(x1, x2);
            std::swap(y1, y2);
        }

        dx = x2 - x1;
        dy = y2 - y1;
        int d = 2 * abs(dy) - dx;
        int y = y1;
        int s = (dy >= 0) ? 1 : -1;

        for (int x = x1; x <= x2; x++) {
            SetPixelSafe(targetDC, x, y, color);
            if (d > 0) {
                y += s;
                d += 2 * (abs(dy) - dx);
            }
            d += 2 * abs(dy);
        }
    }
    else {
        if (y1 > y2) {
            std::swap(x1, x2);
            std::swap(y1, y2);
        }

        dx = x2 - x1;
        dy = y2 - y1;
        int d = 2 * abs(dx) - dy;
        int x = x1;
        int s = (dx >= 0) ? 1 : -1;

        for (int y = y1; y <= y2; y++) {
            SetPixelSafe(targetDC, x, y, color);
            if (d > 0) {
                x += s;
                d += 2 * (abs(dx) - dy);
            }
            d += 2 * abs(dx);
        }
    }
}

void DrawParametricLine(HDC targetDC, POINT p1, POINT p2, COLORREF color) {
    int dx = p2.x - p1.x;
    int dy = p2.y - p1.y;
    double steps = static_cast<double>(max(abs(dx), abs(dy)));

    if (steps == 0) {
        SetPixelSafe(targetDC, p1.x, p1.y, color);
        return;
    }

    double stepX = dx / steps;
    double stepY = dy / steps;

    double currentX = p1.x;
    double currentY = p1.y;

    for (int i = 0; i <= steps; ++i) {
        SetPixelSafe(targetDC, Round(currentX), Round(currentY), color);
        currentX += stepX;
        currentY += stepY;
    }
}

void Draw8Points(HDC targetDC, int xc, int yc, int x, int y, COLORREF c) {
    SetPixelSafe(targetDC, xc + x, yc + y, c);
    SetPixelSafe(targetDC, xc - x, yc + y, c);
    SetPixelSafe(targetDC, xc + x, yc - y, c);
    SetPixelSafe(targetDC, xc - x, yc - y, c);
    SetPixelSafe(targetDC, xc + y, yc + x, c);
    SetPixelSafe(targetDC, xc - y, yc + x, c);
    SetPixelSafe(targetDC, xc + y, yc - x, c);
    SetPixelSafe(targetDC, xc - y, yc - x, c);
}

void DrawDirectCircle(HDC targetDC, int xc, int yc, int r, COLORREF color) {
    int x = 0, y = r;
    int r2 = r * r;
    Draw8Points(targetDC, xc, yc, x, y, color);
    while (x < y) {
        x++;
        y = Round(sqrt(static_cast<double>(r2 - x * x)));
        Draw8Points(targetDC, xc, yc, x, y, color);
    }
}

void DrawPolarCircle(HDC targetDC, int xc, int yc, int r, COLORREF color) {
    double dtheta = 1.0 / r;
    for (double theta = 0; theta <= M_PI_4 + 0.001; theta += dtheta) {
        int x = Round(r * cos(theta));
        int y = Round(r * sin(theta));
        Draw8Points(targetDC, xc, yc, x, y, color);
    }
}

void DrawIterativePolarCircle(HDC targetDC, int xc, int yc, int r, COLORREF color) {
    double dtheta = 1.0 / r;
    double ctheta = cos(dtheta);
    double stheta = sin(dtheta);
    double x = r;
    double y = 0;
    Draw8Points(targetDC, xc, yc, Round(x), Round(y), color);
    while (x > y) {
        double nextX = x * ctheta - y * stheta;
        double nextY = x * stheta + y * ctheta;
        x = nextX;
        y = nextY;
        Draw8Points(targetDC, xc, yc, Round(x), Round(y), color);
    }
}

void DrawMidpointCircle(HDC targetDC, int xc, int yc, int r, COLORREF color) {
    int x = 0, y = r;
    int d = 1 - r;
    while (x <= y) {
        Draw8Points(targetDC, xc, yc, x, y, color);
        if (d < 0)
            d += 2 * x + 3;
        else {
            d += 2 * (x - y) + 5;
            y--;
        }
        x++;
    }
}

void DrawModifiedMidpointCircle(HDC targetDC, int xc, int yc, int r, COLORREF color) {
    int x = 0, y = r;
    int d = 1 - r;
    int d1 = 3;
    int d2 = 5 - 2 * r;
    while (x <= y) {
        Draw8Points(targetDC, xc, yc, x, y, color);
        if (d < 0) {
            d += d1;
            d1 += 2;
            d2 += 2;
        }
        else {
            d += d2;
            d1 += 2;
            d2 += 4;
            y--;
        }
        x++;
    }
}

void Draw4Points(HDC targetDC, int xc, int yc, int x, int y, COLORREF c) {
    SetPixelSafe(targetDC, xc + x, yc + y, c);
    SetPixelSafe(targetDC, xc + x, yc - y, c);
    SetPixelSafe(targetDC, xc - x, yc + y, c);
    SetPixelSafe(targetDC, xc - x, yc - y, c);
}

void DrawDirectEllipse(HDC targetDC, int xc, int yc, int a, int b, COLORREF color) {
    int x = 0;
    int y = b;
    double a2 = static_cast<double>(a * a);
    double b2 = static_cast<double>(b * b);

    Draw4Points(targetDC, xc, yc, x, y, color);
    while (b2 * x <= a2 * y) {
        x++;
        y = Round(b * sqrt(1.0 - (x * x) / a2));
        Draw4Points(targetDC, xc, yc, x, y, color);
    }

    x = a;
    y = 0;
    Draw4Points(targetDC, xc, yc, x, y, color);
    while (b2 * x > a2 * y) {
        y++;
        x = Round(a * sqrt(1.0 - (y * y) / b2));
        Draw4Points(targetDC, xc, yc, x, y, color);
    }
}

void DrawPolarEllipse(HDC targetDC, int xc, int yc, int a, int b, COLORREF color) {
    double dtheta = 1.0 / max(a, b);
    for (double theta = 0; theta <= M_PI_2 + 0.001; theta += dtheta) {
        int x = Round(a * cos(theta));
        int y = Round(b * sin(theta));
        Draw4Points(targetDC, xc, yc, x, y, color);
    }
}

void DrawMidpointEllipse(HDC targetDC, int xc, int yc, int a, int b, COLORREF color) {
    long long a2 = (long long)a * a;
    long long b2 = (long long)b * b;
    long long twoA2 = 2 * a2;
    long long twoB2 = 2 * b2;

    long long x = 0;
    long long y = b;
    long long p;
    long long dx = 0;
    long long dy = twoA2 * b;

    p = round(b2 - a2 * b + 0.25 * a2);
    while (dx < dy) {
        Draw4Points(targetDC, xc, yc, x, y, color);
        x++;
        dx += twoB2;
        if (p < 0) {
            p += dx + b2;
        }
        else {
            y--;
            dy -= twoA2;
            p += dx - dy + b2;
        }
    }

    p = round(b2 * (x + 0.5) * (x + 0.5) + a2 * (y - 1) * (y - 1) - a2 * b2);
    while (y >= 0) {
        Draw4Points(targetDC, xc, yc, x, y, color);
        y--;
        dy -= twoA2;
        if (p > 0) {
            p += a2 - dy;
        }
        else {
            x++;
            dx += twoB2;
            p += dx - dy + a2;
        }
    }
}

void FloodFillRecursive(HDC targetDC, int x, int y, COLORREF fillColor, COLORREF targetColor) {
    if (x < 0 || x >= clientRect.right || y < 0 || y >= clientRect.bottom) {
        return;
    }

    COLORREF currentPxColor = GetPixel(targetDC, x, y);
    if (currentPxColor != targetColor) {
        return;
    }
    if (currentPxColor == fillColor) {
        return;
    }

    SetPixelSafe(targetDC, x, y, fillColor);

    FloodFillRecursive(targetDC, x + 1, y, fillColor, targetColor);
    FloodFillRecursive(targetDC, x - 1, y, fillColor, targetColor);
    FloodFillRecursive(targetDC, x, y + 1, fillColor, targetColor);
    FloodFillRecursive(targetDC, x, y - 1, fillColor, targetColor);
}

void FloodFillNRecursive(HDC targetDC, int x, int y, COLORREF initialPixelColor, COLORREF fillColor) {
    if (x < 0 || x >= clientRect.right || y < 0 || y >= clientRect.bottom) return;
    COLORREF clickedColor = GetPixel(targetDC, x, y);
    if (clickedColor == fillColor) return;

    std::stack<POINT> s;
    s.push({ x, y });

    while (!s.empty()) {
        POINT p = s.top();
        s.pop();

        if (p.x < 0 || p.x >= clientRect.right || p.y < 0 || p.y >= clientRect.bottom) {
            continue;
        }

        COLORREF currentPxColor = GetPixel(targetDC, p.x, p.y);
        if (currentPxColor != clickedColor || currentPxColor == fillColor) {
            continue;
        }

        SetPixelSafe(targetDC, p.x, p.y, fillColor);

        s.push({ p.x + 1, p.y });
        s.push({ p.x - 1, p.y });
        s.push({ p.x, p.y + 1 });
        s.push({ p.x, p.y - 1 });
    }
}

void DrawCardinalSpline(HDC targetDC, const std::vector<POINT>& points, double tension, COLORREF color) {
    if (points.size() < 4) {
        return;
    }

    double s = 0.5 * (1.0 - tension);

    for (size_t i = 1; i < points.size() - 2; ++i) {
        POINT p0 = points[i - 1];
        POINT p1 = points[i];
        POINT p2 = points[i + 1];
        POINT p3 = points[i + 2];

        POINT prev_p = p1;

        for (int j = 0; j <= 100; ++j) {
            double t = static_cast<double>(j) / 100.0;
            double t2 = t * t;
            double t3 = t2 * t;

            double h1 = -s * t3 + 2 * s * t2 - s * t;
            double h2 = (2 - s) * t3 + (s - 3) * t2 + 1;
            double h3 = (s - 2) * t3 + (3 - 2 * s) * t2 + s * t;
            double h4 = s * t3 - s * t2;

            POINT currentP;
            currentP.x = Round(h1 * p0.x + h2 * p1.x + h3 * p2.x + h4 * p3.x);
            currentP.y = Round(h1 * p0.y + h2 * p1.y + h3 * p2.y + h4 * p3.y);

            if (j > 0) {
                DrawLine(targetDC, prev_p.x, prev_p.y, currentP.x, currentP.y, color);
            }
            prev_p = currentP;
        }
    }
}

// Clipping Functions
void DrawClippingWindow(HDC targetDC) {
    HPEN hPen = CreatePen(PS_DASH, 1, RGB(0, 0, 255));
    HPEN hOldPen = (HPEN)SelectObject(targetDC, hPen);
    HBRUSH hOldBrush = (HBRUSH)SelectObject(targetDC, GetStockObject(NULL_BRUSH));

    Rectangle(targetDC, clippingRect.left, clippingRect.top, clippingRect.right, clippingRect.bottom);

    SelectObject(targetDC, hOldPen);
    SelectObject(targetDC, hOldBrush);
    DeleteObject(hPen);
}

void ClipPoint(HDC targetDC, POINT p, COLORREF color) {
    if (p.x >= clippingRect.left && p.x <= clippingRect.right &&
        p.y >= clippingRect.top && p.y <= clippingRect.bottom) {
        SetPixelSafe(targetDC, p.x, p.y, RGB(0, 0, 0));
    }
}

struct outCode {
    unsigned left : 1;
    unsigned right : 1;
    unsigned top : 1;
    unsigned bottom : 1;
};

outCode GetOutCode(double x, double y, double left, double right, double ybottom, double ytop) {
    outCode out = {0};
    if (x < left) out.left = 1;
    else if (x > right) out.right = 1;
    if (y < ybottom) out.bottom = 1;
    else if (y > ytop) out.top = 1;
    return out;
}

POINT VIntersect(double xedge, POINT p1, POINT p2) {
    POINT result;
    result.x = xedge;
    result.y = p1.y + (xedge - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
    return result;
}

POINT HIntersect(double yedge, POINT p1, POINT p2) {
    POINT result;
    result.y = yedge;
    result.x = p1.x + (yedge - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
    return result;
}

void ClipLine(HDC hdc, POINT p1, POINT p2, COLORREF color) {
    double left = clippingRect.left, right = clippingRect.right;
    double ybottom = clippingRect.top, ytop = clippingRect.bottom;
    outCode out1 = GetOutCode(p1.x, p1.y, left, right, ybottom, ytop);
    outCode out2 = GetOutCode(p2.x, p2.y, left, right, ybottom, ytop);

    while (true) {
        if (*(int*)&out1 == 0 && *(int*)&out2 == 0) {
            MoveToEx(hdc, p1.x, p1.y, NULL);
            LineTo(hdc, p2.x, p2.y);
            return;
        } else if ((*(int*)&out1 & *(int*)&out2) != 0) {
            return;
        } else {
            outCode out = (*(int*)&out1) ? out1 : out2;
            POINT newPoint;
            if (out.left) newPoint = VIntersect(left, p1, p2);
            else if (out.right) newPoint = VIntersect(right, p1, p2);
            else if (out.bottom) newPoint = HIntersect(ybottom, p1, p2);
            else newPoint = HIntersect(ytop, p1, p2);

            if (*(int*)&out == *(int*)&out1) {
                p1 = newPoint;
                out1 = GetOutCode(p1.x, p1.y, left, right, ybottom, ytop);
            } else {
                p2 = newPoint;
                out2 = GetOutCode(p2.x, p2.y, left, right, ybottom, ytop);
            }
        }
    }
}

void ClipPolygon(HDC targetDC, const std::vector<POINT>& polygon, COLORREF color) {
    if (polygon.size() < 3) return;

    std::vector<POINT> output = polygon;

    for (int edge = 0; edge < 4; edge++) {
        std::vector<POINT> input = output;
        output.clear();

        POINT s = input.back();
        for (size_t i = 0; i < input.size(); i++) {
            POINT p = input[i];

            bool pInside = false, sInside = false;
            switch (edge) {
                case 0: // Left edge
                    pInside = p.x >= clippingRect.left;
                    sInside = s.x >= clippingRect.left;
                    break;
                case 1: // Right edge
                    pInside = p.x <= clippingRect.right;
                    sInside = s.x <= clippingRect.right;
                    break;
                case 2: // Top edge
                    pInside = p.y >= clippingRect.top;
                    sInside = s.y >= clippingRect.top;
                    break;
                case 3: // Bottom edge
                    pInside = p.y <= clippingRect.bottom;
                    sInside = s.y <= clippingRect.bottom;
                    break;
            }

            if (pInside) {
                if (!sInside) {
                    POINT intersect;
                    switch (edge) {
                        case 0: // Left
                            intersect.x = clippingRect.left;
                            intersect.y = s.y + (p.y - s.y) * (clippingRect.left - s.x) / (p.x - s.x);
                            break;
                        case 1: // Right
                            intersect.x = clippingRect.right;
                            intersect.y = s.y + (p.y - s.y) * (clippingRect.right - s.x) / (p.x - s.x);
                            break;
                        case 2: // Top
                            intersect.y = clippingRect.top;
                            intersect.x = s.x + (p.x - s.x) * (clippingRect.top - s.y) / (p.y - s.y);
                            break;
                        case 3: // Bottom
                            intersect.y = clippingRect.bottom;
                            intersect.x = s.x + (p.x - s.x) * (clippingRect.bottom - s.y) / (p.y - s.y);
                            break;
                    }
                    output.push_back(intersect);
                }
                output.push_back(p);
            }
            else if (sInside) {
                POINT intersect;
                switch (edge) {
                    case 0: // Left
                        intersect.x = clippingRect.left;
                        intersect.y = s.y + (p.y - s.y) * (clippingRect.left - s.x) / (p.x - s.x);
                        break;
                    case 1: // Right
                        intersect.x = clippingRect.right;
                        intersect.y = s.y + (p.y - s.y) * (clippingRect.right - s.x) / (p.x - s.x);
                        break;
                    case 2: // Top
                        intersect.y = clippingRect.top;
                        intersect.x = s.x + (p.x - s.x) * (clippingRect.top - s.y) / (p.y - s.y);
                        break;
                    case 3: // Bottom
                        intersect.y = clippingRect.bottom;
                        intersect.x = s.x + (p.x - s.x) * (clippingRect.bottom - s.y) / (p.y - s.y);
                        break;
                }
                output.push_back(intersect);
            }

            s = p;
        }
    }

    if (output.size() >= 3) {
        POINT first = output[0];
        MoveToEx(targetDC, first.x, first.y, NULL);
        for (size_t i = 1; i < output.size(); i++) {
            LineTo(targetDC, output[i].x, output[i].y);
        }
        LineTo(targetDC, first.x, first.y);
    }
}

void RedrawAllShapesToBitmap(HDC targetDC) {
    HBRUSH hBackgroundBrush = CreateSolidBrush(bgColor);
    FillRect(targetDC, &clientRect, hBackgroundBrush);
    DeleteObject(hBackgroundBrush);

    if (clippingMode != CLIPPING_NONE) {
        DrawClippingWindow(targetDC);
    }

    for (const auto& shape : drawnShapes) {
        switch (shape.type) {
        case SHAPE_LINE:
            switch (shape.line.algo) {
            case LINE_ALGO_BRESENHAM: DrawLine(targetDC, shape.line.p1.x, shape.line.p1.y, shape.line.p2.x, shape.line.p2.y, shape.line.color); break;
            case LINE_ALGO_DDA: DrawDDALine(targetDC, shape.line.p1, shape.line.p2, shape.line.color); break;
            case LINE_ALGO_MIDPOINT: DrawMidpointLine(targetDC, shape.line.p1, shape.line.p2, shape.line.color); break;
            case LINE_ALGO_PARAMETRIC: DrawParametricLine(targetDC, shape.line.p1, shape.line.p2, shape.line.color); break;
            }
            break;
        case SHAPE_CIRCLE:
            switch (shape.circle.algo) {
            case CIRCLE_ALGO_DIRECT: DrawDirectCircle(targetDC, shape.circle.center.x, shape.circle.center.y, shape.circle.radius, shape.circle.color); break;
            case CIRCLE_ALGO_POLAR: DrawPolarCircle(targetDC, shape.circle.center.x, shape.circle.center.y, shape.circle.radius, shape.circle.color); break;
            case CIRCLE_ALGO_ITERATIVE_POLAR: DrawIterativePolarCircle(targetDC, shape.circle.center.x, shape.circle.center.y, shape.circle.radius, shape.circle.color); break;
            case CIRCLE_ALGO_MIDPOINT: DrawMidpointCircle(targetDC, shape.circle.center.x, shape.circle.center.y, shape.circle.radius, shape.circle.color); break;
            case CIRCLE_ALGO_MODIFIED_MIDPOINT: DrawModifiedMidpointCircle(targetDC, shape.circle.center.x, shape.circle.center.y, shape.circle.radius, shape.circle.color); break;
            }
            break;
        case SHAPE_ELLIPSE:
            switch (shape.ellipse.algo) {
            case ELLIPSE_ALGO_DIRECT: DrawDirectEllipse(targetDC, shape.ellipse.center.x, shape.ellipse.center.y, shape.ellipse.a, shape.ellipse.b, shape.ellipse.color); break;
            case ELLIPSE_ALGO_POLAR: DrawPolarEllipse(targetDC, shape.ellipse.center.x, shape.ellipse.center.y, shape.ellipse.a, shape.ellipse.b, shape.ellipse.color); break;
            case ELLIPSE_ALGO_MIDPOINT: DrawMidpointEllipse(targetDC, shape.ellipse.center.x, shape.ellipse.center.y, shape.ellipse.a, shape.ellipse.b, shape.ellipse.color); break;
            }
            break;
        case SHAPE_FILLED_REGION:
            if (shape.filledRegion.algo == FILL_ALGO_RECURSIVE) {
                FloodFillRecursive(targetDC, shape.filledRegion.seedPoint.x, shape.filledRegion.seedPoint.y, shape.filledRegion.fillColor, shape.filledRegion.targetColor);
            }
            else {
                FloodFillNRecursive(targetDC, shape.filledRegion.seedPoint.x, shape.filledRegion.seedPoint.y, shape.filledRegion.boundaryColor, shape.filledRegion.fillColor);
            }
            break;
        case SHAPE_CARDINAL_SPLINE:
            DrawCardinalSpline(targetDC, shape.spline.points, shape.spline.tension, shape.spline.color);
            break;
        case SHAPE_CLIPPED:
            switch (shape.clipped.type) {
                case CLIP_POINT:
                    for (const auto& p : shape.clipped.points) {
                        ClipPoint(targetDC, p, shape.clipped.color);
                    }
                    break;
                case CLIP_LINE:
                    for (size_t i = 0; i + 1 < shape.clipped.points.size(); i += 2) {
                        ClipLine(targetDC, shape.clipped.points[i], shape.clipped.points[i+1], shape.clipped.color);
                    }
                    break;
                case CLIP_POLYGON:
                    if (shape.clipped.points.size() >= 3) {
                        ClipPolygon(targetDC, shape.clipped.points, shape.clipped.color);
                    }
                    break;
            }
            break;
        }
    }

    if (clippingMode != CLIPPING_NONE && !clippingPoints.empty()) {
        DrawClippingWindow(targetDC);
        switch (clippingShapeType) {
            case CLIP_POINT:
                for (const auto& p : clippingPoints) {
                    ClipPoint(targetDC, p, drawColor);
                }
                break;
            case CLIP_LINE:
                for (size_t i = 0; i + 1 < clippingPoints.size(); i += 2) {
                    ClipLine(targetDC, clippingPoints[i], clippingPoints[i+1], drawColor);
                }
                break;
            case CLIP_POLYGON:
                if (clippingPoints.size() >= 3) {
                    ClipPolygon(targetDC, clippingPoints, drawColor);
                }
                break;
        }
        for (const auto& p : clippingPoints) {
            SetPixelSafe(targetDC, p.x, p.y, RGB(255, 0, 0)); // تمييز النقاط باللون الأحمر
        }
    }
}

void SaveShapesToFile(HWND hwnd) {
    OPENFILENAME ofn;
    wchar_t szFile[260];
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = L'\0';
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFilter = L"Drawing Files (*.drw)\0*.drw\0All Files (*.*)\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    if (GetSaveFileName(&ofn) == TRUE) {
        char filePath[MAX_PATH];
        WideCharToMultiByte(CP_ACP, 0, ofn.lpstrFile, -1, filePath, MAX_PATH, NULL, NULL);
        std::ofstream outFile(filePath, std::ios::binary);

        if (outFile.is_open()) {
            outFile.write(reinterpret_cast<const char*>(&drawColor), sizeof(drawColor));
            outFile.write(reinterpret_cast<const char*>(&fillColor), sizeof(fillColor));
            outFile.write(reinterpret_cast<const char*>(&bgColor), sizeof(bgColor));

            size_t numShapes = drawnShapes.size();
            outFile.write(reinterpret_cast<const char*>(&numShapes), sizeof(numShapes));

            for (const auto& shape : drawnShapes) {
                outFile.write(reinterpret_cast<const char*>(&shape.type), sizeof(shape.type));
                switch (shape.type) {
                case SHAPE_LINE:
                    outFile.write(reinterpret_cast<const char*>(&shape.line), sizeof(LineShape));
                    break;
                case SHAPE_CIRCLE:
                    outFile.write(reinterpret_cast<const char*>(&shape.circle), sizeof(CircleShape));
                    break;
                case SHAPE_ELLIPSE:
                    outFile.write(reinterpret_cast<const char*>(&shape.ellipse), sizeof(EllipseShape));
                    break;
                case SHAPE_FILLED_REGION:
                    outFile.write(reinterpret_cast<const char*>(&shape.filledRegion), sizeof(FilledRegionShape));
                    break;
                case SHAPE_CARDINAL_SPLINE: {
                    size_t numPoints = shape.spline.points.size();
                    outFile.write(reinterpret_cast<const char*>(&numPoints), sizeof(numPoints));
                    outFile.write(reinterpret_cast<const char*>(shape.spline.points.data()), numPoints * sizeof(POINT));
                    outFile.write(reinterpret_cast<const char*>(&shape.spline.tension), sizeof(shape.spline.tension));
                    outFile.write(reinterpret_cast<const char*>(&shape.spline.color), sizeof(shape.spline.color));
                    break;
                }
                case SHAPE_CLIPPED: {
                    size_t numPoints = shape.clipped.points.size();
                    outFile.write(reinterpret_cast<const char*>(&shape.clipped.type), sizeof(shape.clipped.type));
                    outFile.write(reinterpret_cast<const char*>(&shape.clipped.color), sizeof(shape.clipped.color));
                    outFile.write(reinterpret_cast<const char*>(&numPoints), sizeof(numPoints));
                    outFile.write(reinterpret_cast<const char*>(shape.clipped.points.data()), numPoints * sizeof(POINT));
                    break;
                }
                }
            }
            outFile.close();
            std::wcout << L"Drawing saved to: " << ofn.lpstrFile << std::endl;
        }
        else {
            MessageBox(hwnd, L"Could not open file for saving.", L"Error", MB_OK | MB_ICONERROR);
        }
    }
}

void LoadShapesFromFile(HWND hwnd) {
    OPENFILENAME ofn;
    wchar_t szFile[260];
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = L'\0';
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFilter = L"Drawing Files (*.drw)\0*.drw\0All Files (*.*)\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    if (GetOpenFileName(&ofn) == TRUE) {
        char filePath[MAX_PATH];
        WideCharToMultiByte(CP_ACP, 0, ofn.lpstrFile, -1, filePath, MAX_PATH, NULL, NULL);
        std::ifstream inFile(filePath, std::ios::binary);

        if (inFile.is_open()) {
            drawnShapes.clear();
            controlPoints.clear();
            clippingPoints.clear();

            inFile.read(reinterpret_cast<char*>(&drawColor), sizeof(drawColor));
            inFile.read(reinterpret_cast<char*>(&fillColor), sizeof(fillColor));
            inFile.read(reinterpret_cast<char*>(&bgColor), sizeof(bgColor));

            size_t numShapes;
            inFile.read(reinterpret_cast<char*>(&numShapes), sizeof(numShapes));

            for (size_t i = 0; i < numShapes; ++i) {
                DrawnShape newShape;
                inFile.read(reinterpret_cast<char*>(&newShape.type), sizeof(newShape.type));

                switch (newShape.type) {
                case SHAPE_LINE:
                    inFile.read(reinterpret_cast<char*>(&newShape.line), sizeof(LineShape));
                    break;
                case SHAPE_CIRCLE:
                    inFile.read(reinterpret_cast<char*>(&newShape.circle), sizeof(CircleShape));
                    break;
                case SHAPE_ELLIPSE:
                    inFile.read(reinterpret_cast<char*>(&newShape.ellipse), sizeof(EllipseShape));
                    break;
                case SHAPE_FILLED_REGION:
                    inFile.read(reinterpret_cast<char*>(&newShape.filledRegion), sizeof(FilledRegionShape));
                    break;
                case SHAPE_CARDINAL_SPLINE: {
                    size_t numPoints;
                    inFile.read(reinterpret_cast<char*>(&numPoints), sizeof(numPoints));
                    newShape.spline.points.resize(numPoints);
                    inFile.read(reinterpret_cast<char*>(newShape.spline.points.data()), numPoints * sizeof(POINT));
                    inFile.read(reinterpret_cast<char*>(&newShape.spline.tension), sizeof(newShape.spline.tension));
                    inFile.read(reinterpret_cast<char*>(&newShape.spline.color), sizeof(newShape.spline.color));
                    break;
                }
                case SHAPE_CLIPPED: {
                    size_t numPoints;
                    inFile.read(reinterpret_cast<char*>(&newShape.clipped.type), sizeof(newShape.clipped.type));
                    inFile.read(reinterpret_cast<char*>(&newShape.clipped.color), sizeof(newShape.clipped.color));
                    inFile.read(reinterpret_cast<char*>(&numPoints), sizeof(numPoints));
                    newShape.clipped.points.resize(numPoints);
                    inFile.read(reinterpret_cast<char*>(newShape.clipped.points.data()), numPoints * sizeof(POINT));
                    break;
                }
                }
                drawnShapes.push_back(newShape);
            }
            inFile.close();
            RedrawAllShapesToBitmap(hMemDC);
            InvalidateRect(hwnd, NULL, FALSE);
            std::wcout << L"Drawing loaded from: " << ofn.lpstrFile << std::endl;
        }
        else {
            MessageBox(hwnd, L"Could not open file for loading.", L"Error", MB_OK | MB_ICONERROR);
        }
    }
}

void CreateMainMenu(HWND hwnd) {
    HMENU hMenu = CreateMenu();
    HMENU hFileMenu = CreatePopupMenu();
    HMENU hColorsMenu = CreatePopupMenu();
    HMENU hDrawColorMenu = CreatePopupMenu();
    HMENU hFillColorMenu = CreatePopupMenu();
    HMENU hBgColorMenu = CreatePopupMenu();
    HMENU hShapesMenu = CreatePopupMenu();
    HMENU hLineEditMenu = CreatePopupMenu();
    HMENU hCircleEditMenu = CreatePopupMenu();
    HMENU hEllipseEditMenu = CreatePopupMenu();
    HMENU hFillMenu = CreatePopupMenu();
    HMENU hCurveMenu = CreatePopupMenu();
    HMENU hEditMenu = CreatePopupMenu();
    HMENU hOptionsMenu = CreatePopupMenu();
    HMENU hCursorMenu = CreatePopupMenu();
    HMENU hClippingMenu = CreatePopupMenu();
    HMENU hClippingShapeMenu = CreatePopupMenu();

    // File Menu
    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hFileMenu, L"&File");
    AppendMenu(hFileMenu, MF_STRING, 1001, L"&New");
    AppendMenu(hFileMenu, MF_STRING, 1002, L"&Open...");
    AppendMenu(hFileMenu, MF_STRING, 1003, L"&Save...");
    AppendMenu(hFileMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hFileMenu, MF_STRING, 1004, L"E&xit");

    // Colors Menu
    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hColorsMenu, L"&Colors");
    AppendMenu(hColorsMenu, MF_POPUP, (UINT_PTR)hDrawColorMenu, L"&Drawing Color");
    AppendMenu(hDrawColorMenu, MF_STRING, 2101, L"&Red");
    AppendMenu(hDrawColorMenu, MF_STRING, 2102, L"&Green");
    AppendMenu(hDrawColorMenu, MF_STRING, 2103, L"&Blue");
    AppendMenu(hDrawColorMenu, MF_STRING, 2104, L"&Black");
    AppendMenu(hDrawColorMenu, MF_STRING, 2105, L"&Yellow");
    AppendMenu(hDrawColorMenu, MF_STRING, 2106, L"&Magenta");
    AppendMenu(hDrawColorMenu, MF_STRING, 2107, L"&Cyan");
    AppendMenu(hDrawColorMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hDrawColorMenu, MF_STRING, 2108, L"&Dark Red");
    AppendMenu(hDrawColorMenu, MF_STRING, 2109, L"&Dark Green");
    AppendMenu(hDrawColorMenu, MF_STRING, 2110, L"&Dark Blue");
    AppendMenu(hDrawColorMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hDrawColorMenu, MF_STRING, 2111, L"&Custom Color...");

    AppendMenu(hColorsMenu, MF_POPUP, (UINT_PTR)hFillColorMenu, L"&Fill Color");
    AppendMenu(hFillColorMenu, MF_STRING, 2201, L"&Red");
    AppendMenu(hFillColorMenu, MF_STRING, 2202, L"&Green");
    AppendMenu(hFillColorMenu, MF_STRING, 2203, L"&Blue");
    AppendMenu(hFillColorMenu, MF_STRING, 2204, L"&Black");
    AppendMenu(hFillColorMenu, MF_STRING, 2205, L"&Yellow");
    AppendMenu(hFillColorMenu, MF_STRING, 2206, L"&Magenta");
    AppendMenu(hFillColorMenu, MF_STRING, 2207, L"&Cyan");
    AppendMenu(hFillColorMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hFillColorMenu, MF_STRING, 2208, L"&Dark Red");
    AppendMenu(hFillColorMenu, MF_STRING, 2209, L"&Dark Green");
    AppendMenu(hFillColorMenu, MF_STRING, 2210, L"&Dark Blue");
    AppendMenu(hFillColorMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hFillColorMenu, MF_STRING, 2211, L"&Custom Color...");

    AppendMenu(hColorsMenu, MF_POPUP, (UINT_PTR)hBgColorMenu, L"&Background Color");
    AppendMenu(hBgColorMenu, MF_STRING, 2301, L"&White");
    AppendMenu(hBgColorMenu, MF_STRING, 2302, L"&Light Gray");
    AppendMenu(hBgColorMenu, MF_STRING, 2303, L"&Gray");
    AppendMenu(hBgColorMenu, MF_STRING, 2304, L"&Black");
    AppendMenu(hBgColorMenu, MF_STRING, 2305, L"&Red");
    AppendMenu(hBgColorMenu, MF_STRING, 2306, L"&Green");
    AppendMenu(hBgColorMenu, MF_STRING, 2307, L"&Blue");
    AppendMenu(hBgColorMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hBgColorMenu, MF_STRING, 2308, L"&Custom Color...");

    // Shapes Menu
    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hShapesMenu, L"&Shapes");
    AppendMenu(hShapesMenu, MF_POPUP, (UINT_PTR)hLineEditMenu, L"&Line");
    AppendMenu(hLineEditMenu, MF_STRING, 3001, L"&Bresenham");
    AppendMenu(hLineEditMenu, MF_STRING, 3002, L"&DDA");
    AppendMenu(hLineEditMenu, MF_STRING, 3003, L"&Midpoint");
    AppendMenu(hLineEditMenu, MF_STRING, 3004, L"&Parametric");

    AppendMenu(hShapesMenu, MF_POPUP, (UINT_PTR)hCircleEditMenu, L"&Circle");
    AppendMenu(hCircleEditMenu, MF_STRING, 4001, L"&Direct");
    AppendMenu(hCircleEditMenu, MF_STRING, 4002, L"&Polar");
    AppendMenu(hCircleEditMenu, MF_STRING, 4003, L"&Iterative Polar");
    AppendMenu(hCircleEditMenu, MF_STRING, 4004, L"&Midpoint");
    AppendMenu(hCircleEditMenu, MF_STRING, 4005, L"&Modified Midpoint");

    AppendMenu(hShapesMenu, MF_POPUP, (UINT_PTR)hEllipseEditMenu, L"&Ellipse");
    AppendMenu(hEllipseEditMenu, MF_STRING, 5001, L"&Direct");
    AppendMenu(hEllipseEditMenu, MF_STRING, 5002, L"&Polar");
    AppendMenu(hEllipseEditMenu, MF_STRING, 5003, L"&Midpoint");

    AppendMenu(hShapesMenu, MF_POPUP, (UINT_PTR)hFillMenu, L"&Fill");
    AppendMenu(hFillMenu, MF_STRING, 6001, L"&Recursive Flood Fill");
    AppendMenu(hFillMenu, MF_STRING, 6002, L"&Non-Recursive Flood Fill");

    AppendMenu(hShapesMenu, MF_POPUP, (UINT_PTR)hCurveMenu, L"&Curves");
    AppendMenu(hCurveMenu, MF_STRING, 7001, L"&Cardinal Spline (4+ points, right click to finish)");

    // Clipping Menu
    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hClippingMenu, L"&Clipping");
    AppendMenu(hClippingMenu, MF_STRING, 10001, L"&Enable Rectangle Clipping");
    AppendMenu(hClippingMenu, MF_STRING, 10002, L"Enable &Square Clipping");
    AppendMenu(hClippingMenu, MF_STRING, 10003, L"&Disable Clipping");
    AppendMenu(hClippingMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hClippingMenu, MF_POPUP, (UINT_PTR)hClippingShapeMenu, L"Clipping &Shape");
    AppendMenu(hClippingShapeMenu, MF_STRING, 10011, L"Clip &Points");
    AppendMenu(hClippingShapeMenu, MF_STRING, 10012, L"Clip &Lines");
    AppendMenu(hClippingShapeMenu, MF_STRING, 10013, L"Clip &Polygon");
    AppendMenu(hClippingShapeMenu, MF_STRING, 10014, L"&Clear Clipping Points");

    // Edit Menu
    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hEditMenu, L"&Edit");
    AppendMenu(hEditMenu, MF_STRING, 8001, L"&Clear Screen");

    // Options Menu
    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hOptionsMenu, L"&Options");
    AppendMenu(hOptionsMenu, MF_POPUP, (UINT_PTR)hCursorMenu, L"Change &Mouse Cursor");
    AppendMenu(hCursorMenu, MF_STRING, 9001, L"&Arrow");
    AppendMenu(hCursorMenu, MF_STRING, 9002, L"&Hand");
    AppendMenu(hCursorMenu, MF_STRING, 9003, L"&Wait");
    AppendMenu(hCursorMenu, MF_STRING, 9004, L"&Cross");
    AppendMenu(hCursorMenu, MF_STRING, 9005, L"&Help");

    SetMenu(hwnd, hMenu);
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    HDC hdc;
    PAINTSTRUCT ps;
    static HCURSOR hCursorArrow, hCursorHand, hCursorWait, hCursorCross, hCursorHelp;

    switch (message) {
    case WM_CREATE:
        GetClientRect(hwnd, &clientRect);

        hdc = GetDC(hwnd);
        hMemDC = CreateCompatibleDC(hdc);
        hBitmap = CreateCompatibleBitmap(hdc, clientRect.right, clientRect.bottom);
        hOldBitmap = (HBITMAP)SelectObject(hMemDC, hBitmap);
        ReleaseDC(hwnd, hdc);

        RedrawAllShapesToBitmap(hMemDC);

        hCursorArrow = LoadCursor(NULL, IDC_ARROW);
        hCursorHand = LoadCursor(NULL, IDC_HAND);
        hCursorWait = LoadCursor(NULL, IDC_WAIT);
        hCursorCross = LoadCursor(NULL, IDC_CROSS);
        hCursorHelp = LoadCursor(NULL, IDC_HELP);
        SetCursor(hCursorArrow);

        CreateMainMenu(hwnd);
        AllocConsole();
        FILE* consoleOutput;
        if (freopen_s(&consoleOutput, "CONOUT$", "w", stdout) != 0) {
            MessageBox(hwnd, L"Failed to redirect console output.", L"Error", MB_OK | MB_ICONERROR);
        }
        std::wcout.imbue(std::locale(""));
        std::wcout << L"Console opened. Drawing application running." << std::endl;
        std::wcout << L"Current Drawing Color: R" << GetRValue(drawColor) << L" G" << GetGValue(drawColor) << L" B" << GetBValue(drawColor) << std::endl;
        std::wcout << L"Current Fill Color: R" << GetRValue(fillColor) << L" G" << GetGValue(fillColor) << L" B" << GetBValue(fillColor) << std::endl;
        std::wcout << L"Current Background Color: R" << GetRValue(bgColor) << L" G" << GetGValue(bgColor) << L" B" << GetBValue(bgColor) << std::endl;
        break;

    case WM_SIZE:
        GetClientRect(hwnd, &clientRect);
        if (hMemDC && hOldBitmap) {
            SelectObject(hMemDC, hOldBitmap);
            DeleteObject(hBitmap);
        }
        hdc = GetDC(hwnd);
        hBitmap = CreateCompatibleBitmap(hdc, clientRect.right, clientRect.bottom);
        hOldBitmap = (HBITMAP)SelectObject(hMemDC, hBitmap);
        ReleaseDC(hwnd, hdc);

        RedrawAllShapesToBitmap(hMemDC);
        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_COMMAND:
    {
        int wmId = LOWORD(wParam);
        switch (wmId) {
            // File Menu
        case 1001: // New
            drawnShapes.clear();
            controlPoints.clear();
            clippingPoints.clear();
            drawColor = RGB(0, 0, 0);
            fillColor = RGB(255, 0, 0);
            bgColor = RGB(255, 255, 255);
            clippingMode = CLIPPING_NONE;
            RedrawAllShapesToBitmap(hMemDC);
            InvalidateRect(hwnd, NULL, FALSE);
            drawingMode = MODE_NONE;
            SetCursor(hCursorArrow);
            std::wcout << L"New drawing created. Screen cleared and colors reset." << std::endl;
            break;
        case 1002: // Open
            LoadShapesFromFile(hwnd);
            break;
        case 1003: // Save
            SaveShapesToFile(hwnd);
            break;
        case 1004: // Exit
            DestroyWindow(hwnd);
            break;

            // Colors Menu - Drawing Color
        case 2101: drawColor = RGB(255, 0, 0); std::wcout << L"Drawing Color: Red" << std::endl; break;
        case 2102: drawColor = RGB(0, 255, 0); std::wcout << L"Drawing Color: Green" << std::endl; break;
        case 2103: drawColor = RGB(0, 0, 255); std::wcout << L"Drawing Color: Blue" << std::endl; break;
        case 2104: drawColor = RGB(0, 0, 0);   std::wcout << L"Drawing Color: Black" << std::endl; break;
        case 2105: drawColor = RGB(255, 255, 0); std::wcout << L"Drawing Color: Yellow" << std::endl; break;
        case 2106: drawColor = RGB(255, 0, 255); std::wcout << L"Drawing Color: Magenta" << std::endl; break;
        case 2107: drawColor = RGB(0, 255, 255); std::wcout << L"Drawing Color: Cyan" << std::endl; break;
        case 2108: drawColor = RGB(128, 0, 0); std::wcout << L"Drawing Color: Dark Red" << std::endl; break;
        case 2109: drawColor = RGB(0, 128, 0); std::wcout << L"Drawing Color: Dark Green" << std::endl; break;
        case 2110: drawColor = RGB(0, 0, 128); std::wcout << L"Drawing Color: Dark Blue" << std::endl; break;
        case 2111: { // Custom Drawing Color
            CHOOSECOLOR cc;
            ZeroMemory(&cc, sizeof(cc));
            COLORREF acrCustColors[16];
            cc.lStructSize = sizeof(cc);
            cc.hwndOwner = hwnd;
            cc.lpCustColors = (LPDWORD)acrCustColors;
            cc.rgbResult = drawColor;
            cc.Flags = CC_FULLOPEN | CC_RGBINIT;

            if (ChooseColor(&cc) == TRUE) {
                drawColor = cc.rgbResult;
                std::wcout << L"Drawing Color: Custom (R" << GetRValue(drawColor) << L" G" << GetGValue(drawColor) << L" B" << GetBValue(drawColor) << L")" << std::endl;
            }
            break;
        }

                 // Colors Menu - Fill Color
        case 2201: fillColor = RGB(255, 0, 0); std::wcout << L"Fill Color: Red" << std::endl; break;
        case 2202: fillColor = RGB(0, 255, 0); std::wcout << L"Fill Color: Green" << std::endl; break;
        case 2203: fillColor = RGB(0, 0, 255); std::wcout << L"Fill Color: Blue" << std::endl; break;
        case 2204: fillColor = RGB(0, 0, 0);   std::wcout << L"Fill Color: Black" << std::endl; break;
        case 2205: fillColor = RGB(255, 255, 0); std::wcout << L"Fill Color: Yellow" << std::endl; break;
        case 2206: fillColor = RGB(255, 0, 255); std::wcout << L"Fill Color: Magenta" << std::endl; break;
        case 2207: fillColor = RGB(0, 255, 255); std::wcout << L"Fill Color: Cyan" << std::endl; break;
        case 2208: fillColor = RGB(128, 0, 0); std::wcout << L"Fill Color: Dark Red" << std::endl; break;
        case 2209: fillColor = RGB(0, 128, 0); std::wcout << L"Fill Color: Dark Green" << std::endl; break;
        case 2210: fillColor = RGB(0, 0, 128); std::wcout << L"Fill Color: Dark Blue" << std::endl; break;
        case 2211: { // Custom Fill Color
            CHOOSECOLOR cc;
            ZeroMemory(&cc, sizeof(cc));
            COLORREF acrCustColors[16];
            cc.lStructSize = sizeof(cc);
            cc.hwndOwner = hwnd;
            cc.lpCustColors = (LPDWORD)acrCustColors;
            cc.rgbResult = fillColor;
            cc.Flags = CC_FULLOPEN | CC_RGBINIT;

            if (ChooseColor(&cc) == TRUE) {
                fillColor = cc.rgbResult;
                std::wcout << L"Fill Color: Custom (R" << GetRValue(fillColor) << L" G" << GetGValue(fillColor) << L" B" << GetBValue(fillColor) << L")" << std::endl;
            }
            break;
        }

                 // Colors Menu - Background Color
        case 2301: bgColor = RGB(255, 255, 255); RedrawAllShapesToBitmap(hMemDC); InvalidateRect(hwnd, NULL, FALSE); std::wcout << L"Background Color: White" << std::endl; break;
        case 2302: bgColor = RGB(192, 192, 192); RedrawAllShapesToBitmap(hMemDC); InvalidateRect(hwnd, NULL, FALSE); std::wcout << L"Background Color: Light Gray" << std::endl; break;
        case 2303: bgColor = RGB(128, 128, 128); RedrawAllShapesToBitmap(hMemDC); InvalidateRect(hwnd, NULL, FALSE); std::wcout << L"Background Color: Gray" << std::endl; break;
        case 2304: bgColor = RGB(0, 0, 0); RedrawAllShapesToBitmap(hMemDC); InvalidateRect(hwnd, NULL, FALSE); std::wcout << L"Background Color: Black" << std::endl; break;
        case 2305: bgColor = RGB(255, 0, 0); RedrawAllShapesToBitmap(hMemDC); InvalidateRect(hwnd, NULL, FALSE); std::wcout << L"Background Color: Red" << std::endl; break;
        case 2306: bgColor = RGB(0, 255, 0); RedrawAllShapesToBitmap(hMemDC); InvalidateRect(hwnd, NULL, FALSE); std::wcout << L"Background Color: Green" << std::endl; break;
        case 2307: bgColor = RGB(0, 0, 255); RedrawAllShapesToBitmap(hMemDC); InvalidateRect(hwnd, NULL, FALSE); std::wcout << L"Background Color: Blue" << std::endl; break;
        case 2308: { // Custom Background Color
            CHOOSECOLOR cc;
            ZeroMemory(&cc, sizeof(cc));
            COLORREF acrCustColors[16];
            cc.lStructSize = sizeof(cc);
            cc.hwndOwner = hwnd;
            cc.lpCustColors = (LPDWORD)acrCustColors;
            cc.rgbResult = bgColor;
            cc.Flags = CC_FULLOPEN | CC_RGBINIT;

            if (ChooseColor(&cc) == TRUE) {
                bgColor = cc.rgbResult;
                RedrawAllShapesToBitmap(hMemDC);
                InvalidateRect(hwnd, NULL, FALSE);
                std::wcout << L"Background Color: Custom (R" << GetRValue(bgColor) << L" G" << GetGValue(bgColor) << L" B" << GetBValue(bgColor) << L")" << std::endl;
            }
            break;
        }

                 // Shapes Menu - Lines
        case 3001: drawingMode = MODE_DRAW_LINE; lineAlgorithm = LINE_ALGO_BRESENHAM; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Line (Bresenham)" << std::endl; break;
        case 3002: drawingMode = MODE_DRAW_LINE; lineAlgorithm = LINE_ALGO_DDA; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Line (DDA)" << std::endl; break;
        case 3003: drawingMode = MODE_DRAW_LINE; lineAlgorithm = LINE_ALGO_MIDPOINT; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Line (Midpoint)" << std::endl; break;
        case 3004: drawingMode = MODE_DRAW_LINE; lineAlgorithm = LINE_ALGO_PARAMETRIC; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Line (Parametric)" << std::endl; break;

            // Shapes Menu - Circles
        case 4001: drawingMode = MODE_DRAW_CIRCLE; circleAlgorithm = CIRCLE_ALGO_DIRECT; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Circle (Direct)" << std::endl; break;
        case 4002: drawingMode = MODE_DRAW_CIRCLE; circleAlgorithm = CIRCLE_ALGO_POLAR; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Circle (Polar)" << std::endl; break;
        case 4003: drawingMode = MODE_DRAW_CIRCLE; circleAlgorithm = CIRCLE_ALGO_ITERATIVE_POLAR; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Circle (Iterative Polar)" << std::endl; break;
        case 4004: drawingMode = MODE_DRAW_CIRCLE; circleAlgorithm = CIRCLE_ALGO_MIDPOINT; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Circle (Midpoint)" << std::endl; break;
        case 4005: drawingMode = MODE_DRAW_CIRCLE; circleAlgorithm = CIRCLE_ALGO_MODIFIED_MIDPOINT; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Circle (Modified Midpoint)" << std::endl; break;

            // Shapes Menu - Ellipses
        case 5001: drawingMode = MODE_DRAW_ELLIPSE; ellipseAlgorithm = ELLIPSE_ALGO_DIRECT; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Ellipse (Direct)" << std::endl; break;
        case 5002: drawingMode = MODE_DRAW_ELLIPSE; ellipseAlgorithm = ELLIPSE_ALGO_POLAR; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Ellipse (Polar)" << std::endl; break;
        case 5003: drawingMode = MODE_DRAW_ELLIPSE; ellipseAlgorithm = ELLIPSE_ALGO_MIDPOINT; SetCursor(hCursorCross); std::wcout << L"Mode: Draw Ellipse (Midpoint)" << std::endl; break;

            // Shapes Menu - Flood Fill
        case 6001: drawingMode = MODE_FLOOD_FILL; fillAlgorithm = FILL_ALGO_RECURSIVE; SetCursor(hCursorCross); std::wcout << L"Mode: Flood Fill (Recursive)" << std::endl; break;
        case 6002: drawingMode = MODE_FLOOD_FILL; fillAlgorithm = FILL_ALGO_NON_RECURSIVE; SetCursor(hCursorCross); std::wcout << L"Mode: Flood Fill (Non-Recursive)" << std::endl; break;

            // Shapes Menu - Curves
        case 7001: drawingMode = MODE_CARDINAL_SPLINE; controlPoints.clear(); SetCursor(hCursorCross); std::wcout << L"Mode: Cardinal Spline (Click for points, Right-click to finish)" << std::endl; break;

            // Clipping Menu
        case 10001: // Enable Rectangle Clipping
            clippingMode = CLIPPING_RECTANGLE;
            RedrawAllShapesToBitmap(hMemDC);
            clippingPoints.clear();
            drawingMode = MODE_NONE;
            std::wcout << L"Rectangle Clipping Enabled" << std::endl;
            InvalidateRect(hwnd, NULL, FALSE);
            break;
        case 10002: // Enable Square Clipping
            clippingMode = CLIPPING_SQUARE;
            clippingRect.right = clippingRect.left + (clippingRect.bottom - clippingRect.top);
             RedrawAllShapesToBitmap(hMemDC);
            clippingPoints.clear();
            drawingMode = MODE_NONE;
            std::wcout << L"Square Clipping Enabled" << std::endl;
            InvalidateRect(hwnd, NULL, FALSE);
            break;
        case 10003: // Disable Clipping
            clippingMode = CLIPPING_NONE;
            clippingPoints.clear();
            std::wcout << L"Clipping Disabled" << std::endl;
            InvalidateRect(hwnd, NULL, FALSE);
            break;

            // Clipping Shape Menu
        case 10011: // Clip Points
            clippingShapeType = CLIP_POINT;
            clippingPoints.clear();
            std::wcout << L"Clipping Points Mode" << std::endl;
            break;
        case 10012: // Clip Lines
            clippingShapeType = CLIP_LINE;
            clippingPoints.clear();
            std::wcout << L"Clipping Lines Mode" << std::endl;
            break;
        case 10013: // Clip Polygon
            clippingShapeType = CLIP_POLYGON;
            clippingPoints.clear();
            std::wcout << L"Clipping Polygon Mode" << std::endl;
            break;
        case 10014: // Clear Clipping Points
            clippingPoints.clear();
            std::wcout << L"Clipping Points Cleared" << std::endl;
            InvalidateRect(hwnd, NULL, FALSE);
            break;

            // Edit Menu
        case 8001: // Clear Screen
            drawnShapes.clear();
            controlPoints.clear();
            clippingPoints.clear();
            RedrawAllShapesToBitmap(hMemDC);
            InvalidateRect(hwnd, NULL, FALSE);
            drawingMode = MODE_NONE;
            clippingMode = CLIPPING_NONE;
            SetCursor(hCursorArrow);
            std::wcout << L"Screen cleared." << std::endl;
            break;

            // Options Menu - Mouse Cursors
        case 9001: SetCursor(hCursorArrow); std::wcout << L"Cursor: Arrow" << std::endl; break;
        case 9002: SetCursor(hCursorHand); std::wcout << L"Cursor: Hand" << std::endl; break;
        case 9003: SetCursor(hCursorWait); std::wcout << L"Cursor: Wait" << std::endl; break;
        case 9004: SetCursor(hCursorCross); std::wcout << L"Cursor: Cross" << std::endl; break;
        case 9005: SetCursor(hCursorHelp); std::wcout << L"Cursor: Help" << std::endl; break;

        default:
            break;
        }
    }
    break;

    case WM_LBUTTONDOWN:
        if (clippingMode != CLIPPING_NONE) {
            POINT p = { LOWORD(lParam), HIWORD(lParam) };

            SetPixelSafe(hMemDC, p.x, p.y, RGB(255, 0, 0));

            if(clippingShapeType == CLIP_POINT){
                if (p.x >= clippingRect.left && p.x <= clippingRect.right && p.y >= clippingRect.top && p.y <= clippingRect.bottom) {
                        clippingPoints.push_back(p);
                    SetPixelSafe(hMemDC, p.x, p.y, drawColor);
                }
                else {

                    std::wcout << L"Point (" << p.x << L"," << p.y << L") is outside clipping region - ignored" << std::endl;
                    return 0;

                }
            }


            InvalidateRect(hwnd, NULL, FALSE);

        clippingPoints.push_back(p);


        if (clippingShapeType == CLIP_LINE && clippingPoints.size() == 2) {
            ClipLine(hMemDC, clippingPoints[0], clippingPoints[1], drawColor);


            InvalidateRect(hwnd, NULL, FALSE);
        }
            RedrawAllShapesToBitmap(hMemDC);
            InvalidateRect(hwnd, NULL, FALSE);
            std::wcout << L"Clipping point added: (" << p.x << L", " << p.y << L")" << std::endl;
        }
        else {
            startPoint.x = LOWORD(lParam);
            startPoint.y = HIWORD(lParam);
            isDrawing = true;

            if (drawingMode == MODE_FLOOD_FILL) {
                COLORREF targetColor = GetPixel(hMemDC, startPoint.x, startPoint.y);

                if (targetColor == fillColor) {
                    std::wcout << L"Clicked on an area already filled with the current fill color." << std::endl;
                    return 0;
                }

                DrawnShape newShape;
                newShape.type = SHAPE_FILLED_REGION;
                newShape.filledRegion.seedPoint = startPoint;
                newShape.filledRegion.fillColor = fillColor;
                newShape.filledRegion.algo = fillAlgorithm;

                if (fillAlgorithm == FILL_ALGO_RECURSIVE) {
                    newShape.filledRegion.targetColor = targetColor;
                    FloodFillRecursive(hMemDC, startPoint.x, startPoint.y, fillColor, targetColor);
                }
                else {
                    newShape.filledRegion.targetColor = targetColor;
                    FloodFillNRecursive(hMemDC, startPoint.x, startPoint.y, targetColor, fillColor);
                }
                drawnShapes.push_back(newShape);
                InvalidateRect(hwnd, NULL, FALSE);
            }
            else if (drawingMode == MODE_CARDINAL_SPLINE) {
                controlPoints.push_back(startPoint);
                InvalidateRect(hwnd, NULL, FALSE);
                std::wcout << L"Control Point added: (" << startPoint.x << L", " << startPoint.y << L")" << std::endl;
            }
        }
        break;

    case WM_MOUSEMOVE:
        if (isDrawing && drawingMode != MODE_FLOOD_FILL && drawingMode != MODE_CARDINAL_SPLINE && clippingMode == CLIPPING_NONE) {
            endPoint.x = LOWORD(lParam);
            endPoint.y = HIWORD(lParam);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        break;

    case WM_LBUTTONUP:
        if (isDrawing && drawingMode != MODE_FLOOD_FILL && drawingMode != MODE_CARDINAL_SPLINE && clippingMode == CLIPPING_NONE) {
            endPoint.x = LOWORD(lParam);
            endPoint.y = HIWORD(lParam);
            isDrawing = false;

            DrawnShape newShape;

            if (drawingMode == MODE_DRAW_LINE) {
                newShape.type = SHAPE_LINE;
                newShape.line.p1 = startPoint;
                newShape.line.p2 = endPoint;
                newShape.line.color = drawColor;
                newShape.line.algo = lineAlgorithm;

                switch (lineAlgorithm) {
                case LINE_ALGO_BRESENHAM: DrawLine(hMemDC, startPoint.x, startPoint.y, endPoint.x, endPoint.y, drawColor); break;
                case LINE_ALGO_DDA: DrawDDALine(hMemDC, startPoint, endPoint, drawColor); break;
                case LINE_ALGO_MIDPOINT: DrawMidpointLine(hMemDC, startPoint, endPoint, drawColor); break;
                case LINE_ALGO_PARAMETRIC: DrawParametricLine(hMemDC, startPoint, endPoint, drawColor); break;
                }
            }
            else if (drawingMode == MODE_DRAW_CIRCLE) {
                newShape.type = SHAPE_CIRCLE;
                newShape.circle.center = startPoint;
                newShape.circle.radius = static_cast<int>(sqrt(pow(endPoint.x - startPoint.x, 2) + pow(endPoint.y - startPoint.y, 2)));
                newShape.circle.color = drawColor;
                newShape.circle.algo = circleAlgorithm;

                switch (circleAlgorithm) {
                case CIRCLE_ALGO_DIRECT: DrawDirectCircle(hMemDC, startPoint.x, startPoint.y, newShape.circle.radius, drawColor); break;
                case CIRCLE_ALGO_POLAR: DrawPolarCircle(hMemDC, startPoint.x, startPoint.y, newShape.circle.radius, drawColor); break;
                case CIRCLE_ALGO_ITERATIVE_POLAR: DrawIterativePolarCircle(hMemDC, startPoint.x, startPoint.y, newShape.circle.radius, drawColor); break;
                case CIRCLE_ALGO_MIDPOINT: DrawMidpointCircle(hMemDC, startPoint.x, startPoint.y, newShape.circle.radius, drawColor); break;
                case CIRCLE_ALGO_MODIFIED_MIDPOINT: DrawModifiedMidpointCircle(hMemDC, startPoint.x, startPoint.y, newShape.circle.radius, drawColor); break;
                }
            }
            else if (drawingMode == MODE_DRAW_ELLIPSE) {
                newShape.type = SHAPE_ELLIPSE;
                newShape.ellipse.center = startPoint;
                newShape.ellipse.a = abs(endPoint.x - startPoint.x);
                newShape.ellipse.b = abs(endPoint.y - startPoint.y);
                newShape.ellipse.color = drawColor;
                newShape.ellipse.algo = ellipseAlgorithm;

                switch (ellipseAlgorithm) {
                case ELLIPSE_ALGO_DIRECT: DrawDirectEllipse(hMemDC, startPoint.x, startPoint.y, newShape.ellipse.a, newShape.ellipse.b, drawColor); break;
                case ELLIPSE_ALGO_POLAR: DrawPolarEllipse(hMemDC, startPoint.x, startPoint.y, newShape.ellipse.a, newShape.ellipse.b, drawColor); break;
                case ELLIPSE_ALGO_MIDPOINT: DrawMidpointEllipse(hMemDC, startPoint.x, startPoint.y, newShape.ellipse.a, newShape.ellipse.b, drawColor); break;
                }
            }
            drawnShapes.push_back(newShape);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        SetCursor(hCursorArrow);
        break;

    case WM_RBUTTONDOWN:
        if (clippingMode != CLIPPING_NONE) {
            if (clippingShapeType == CLIP_POLYGON && clippingPoints.size() >= 3) {
                DrawnShape newShape;
                newShape.type = SHAPE_CLIPPED;
                newShape.clipped.points = clippingPoints;
                newShape.clipped.color = drawColor;
                newShape.clipped.type = clippingShapeType;
                drawnShapes.push_back(newShape);

                ClipPolygon(hMemDC, clippingPoints, drawColor);
                RedrawAllShapesToBitmap(hMemDC);
                clippingPoints.clear();
                InvalidateRect(hwnd, NULL, FALSE);
            }
            else if (clippingShapeType == CLIP_LINE && clippingPoints.size() >= 2) {
                DrawnShape newShape;
                newShape.type = SHAPE_CLIPPED;
                newShape.clipped.points = clippingPoints;
                newShape.clipped.color = drawColor;
                newShape.clipped.type = clippingShapeType;
                drawnShapes.push_back(newShape);

                ClipLine(hMemDC, clippingPoints[0], clippingPoints[1], drawColor);
                clippingPoints.clear();
                InvalidateRect(hwnd, NULL, FALSE);
            }
            else if (clippingShapeType == CLIP_POINT) {
                if (!clippingPoints.empty()) {
                    DrawnShape newShape;
                    newShape.type = SHAPE_CLIPPED;
                    newShape.clipped.points = clippingPoints;
                    newShape.clipped.color = drawColor;
                    newShape.clipped.type = clippingShapeType;
                    drawnShapes.push_back(newShape);

                    for (const auto& p : clippingPoints) {
                        ClipPoint(hMemDC, p, drawColor);
                    }
                    clippingPoints.clear();
                    InvalidateRect(hwnd, NULL, FALSE);
                }
            }
        }
        else if (drawingMode == MODE_CARDINAL_SPLINE) {
            if (controlPoints.size() >= 4) {
                DrawnShape newShape;
                newShape.type = SHAPE_CARDINAL_SPLINE;
                newShape.spline.points = controlPoints;
                newShape.spline.tension = 0.0;
                newShape.spline.color = drawColor;
                drawnShapes.push_back(newShape);

                DrawCardinalSpline(hMemDC, newShape.spline.points, newShape.spline.tension, newShape.spline.color);

                controlPoints.clear();
                InvalidateRect(hwnd, NULL, FALSE);
                drawingMode = MODE_NONE;
                SetCursor(hCursorArrow);
                std::wcout << L"Cardinal Spline finished." << std::endl;
            }
            else {
                MessageBox(hwnd, L"Cardinal Spline requires at least 4 control points. Right click to cancel or continue adding points.", L"Warning", MB_OK | MB_ICONWARNING);
                controlPoints.clear();
                RedrawAllShapesToBitmap(hMemDC);
                InvalidateRect(hwnd, NULL, FALSE);
                drawingMode = MODE_NONE;
                SetCursor(hCursorArrow);
            }
        }
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        BitBlt(hdc, 0, 0, clientRect.right, clientRect.bottom, hMemDC, 0, 0, SRCCOPY);

         if (clippingMode != CLIPPING_NONE && !clippingPoints.empty()) {
        for (const auto& p : clippingPoints) {
                    SetPixelSafe(hMemDC, p.x, p.y, drawColor);
                
        }
    }

        if (isDrawing && drawingMode != MODE_FLOOD_FILL && drawingMode != MODE_CARDINAL_SPLINE && clippingMode == CLIPPING_NONE) {
            switch (drawingMode) {
            case MODE_DRAW_LINE:
                DrawLine(hdc, startPoint.x, startPoint.y, endPoint.x, endPoint.y, drawColor);
                break;
            case MODE_DRAW_CIRCLE: {
                int r = static_cast<int>(sqrt(pow(endPoint.x - startPoint.x, 2) + pow(endPoint.y - startPoint.y, 2)));
                DrawDirectCircle(hdc, startPoint.x, startPoint.y, r, drawColor);
                break;
            }
            case MODE_DRAW_ELLIPSE: {
                int a = abs(endPoint.x - startPoint.x);
                int b = abs(endPoint.y - startPoint.y);
                DrawDirectEllipse(hdc, startPoint.x, startPoint.y, a, b, drawColor);
                break;
            }
            }
        }
        else if (drawingMode == MODE_CARDINAL_SPLINE) {
            for (const auto& p : controlPoints) {
                SetPixelSafe(hdc, p.x, p.y, RGB(255, 0, 255));
                DrawDirectCircle(hdc, p.x, p.y, 2, RGB(255, 0, 255));
            }
            if (controlPoints.size() >= 4) {
                DrawCardinalSpline(hdc, controlPoints, 0.0, drawColor);
            }
        }
        else if (clippingMode != CLIPPING_NONE) {
            for (const auto& p : clippingPoints) {
                SetPixelSafe(hdc, p.x, p.y, RGB(255, 0, 255));
                DrawDirectCircle(hdc, p.x, p.y, 2, RGB(255, 0, 255));
            }
        }

        EndPaint(hwnd, &ps);
        break;

    case WM_ERASEBKGND:
        return TRUE;

    case WM_DESTROY:
        if (hMemDC) {
            SelectObject(hMemDC, hOldBitmap);
            DeleteDC(hMemDC);
        }
        if (hBitmap) {
            DeleteObject(hBitmap);
        }
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}

void RegisterMyClass(HINSTANCE hInstance) {
    WNDCLASSEX wc;
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = L"GraphicsAppClass";
    wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

    if (!RegisterClassEx(&wc)) {
        MessageBox(NULL, L"Window Registration Failed!", L"Error!", MB_ICONEXCLAMATION | MB_OK);
        return;
    }
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    RegisterMyClass(hInstance);

    HWND hwnd = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        L"GraphicsAppClass",
        L"Graphics Drawing Application",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600,
        NULL, NULL, hInstance, NULL);

    if (hwnd == NULL) {
        MessageBox(NULL, L"Window Creation Failed!", L"Error!", MB_ICONEXCLAMATION | MB_OK);
        return 0;
    }

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    MSG Msg;
    while (GetMessage(&Msg, NULL, 0, 0) > 0) {
        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }
    return static_cast<int>(Msg.wParam);
}
