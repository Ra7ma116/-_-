#include <windows.h> // Required for Win32 API
#include <windowsx.h> // For GET_X_LPARAM, GET_Y_LPARAM
#include <GL/gl.h>    // OpenGL32 library
#include <GL/glu.h>   // GLu library (for gluOrtho2D)
#include <vector>
#include <cmath>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <limits> // For std::numeric_limits
#include <algorithm> // For std::sort, std::copy

// Define M_PI if it's not defined by default (e.g., in MSVC)
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
#ifndef M_PI_2
#define M_PI_2 1.57079632679489661923 // PI/2
#endif
#ifndef M_PI_4
#define M_PI_4 0.785398163397448309616 // PI/4
#endif

// Global handles and device contexts
HDC hDC = NULL;         // Private GDI Device Context
HGLRC hRC = NULL;       // Permanent Rendering Context
HWND hWnd = NULL;       // Window Handle
HINSTANCE hInstance;    // Application Instance

// Window dimensions
int windowWidth = 800;
int windowHeight = 600;

// Current drawing color (RGBA)
float currentColor[4] = { 0.0f, 0.0f, 0.0f, 1.0f }; // Default: Black

// Mouse position for drawing
int mouseX = 0;
int mouseY = 0;

// Drawing mode (0: None, 1: MyPoint, 2: MyLine, 3: MyCircle, 4: MyEllipse, 5: MyPolygon, 6: MyCardinal Spline, 7: MyBezier Curve)
int drawingMode = 0;

// Specific algorithm selection within a mode
// Line algorithms: 0: DDA, 1: Midpoint, 2: Parametric
int lineAlgorithm = 0;
// Circle algorithms: 0: Direct, 1: Polar, 2: Iterative Polar, 3: Midpoint, 4: Modified Midpoint
int circleAlgorithm = 0;
// Ellipse algorithms: 0: Direct, 1: Polar, 2: Midpoint
int ellipseAlgorithm = 0;

// Filling modes for circles
// 0: None, 1: Lines, 2: Circles
int circleFillMode = 0;
int circleFillQuarter = 0; // 1, 2, 3, 4 (0 for full circle)

// Clipping related variables
bool clippingEnabled = false;
float clipWindowMinX = 200, clipWindowMinY = 200;
float clipWindowMaxX = 600, clipWindowMaxY = 400;
// Clipping type: 0: MyPoint, 1: MyLine, 2: MyPolygon
int clippingType = 0;
// Clipping window shape: 0: Rectangle, 1: Square
int clippingWindowShape = 0; // Adjusts clipWindowMaxY to match width for square

// --- Data Structures to store drawn shapes ---
// Renamed structs with My prefix to avoid name conflicts with Win32 GDI functions
typedef struct MyPoint_t {
    float x, y;
    float color[4];
} MyPoint;

typedef struct MyLine_t {
    float x0, y0, x1, y1;
    float color[4];
    int algorithm; // Stores which line algorithm was used (0: DDA, 1: Midpoint, 2: Parametric)
} MyLine;

typedef struct MyCircle_t {
    float xc, yc, r;
    float color[4];
    int algorithm; // Stores which circle algorithm was used
    int fillMode; // 0: None, 1: Lines, 2: Circles
    int fillQuarter; // 1, 2, 3, 4 (0 for full circle fill)
} MyCircle;

typedef struct MyEllipse_t { // Now named MyEllipse_t, aliased as MyEllipse
    float xc, yc, rx, ry;
    float color[4];
    int algorithm; // Stores which ellipse algorithm was used
} MyEllipse;

typedef struct MyPolygon_t { // Now named MyPolygon_t, aliased as MyPolygon
    std::vector<MyPoint> vertices;
    float color[4];
} MyPolygon;

typedef struct MyCurve_t {
    std::vector<MyPoint> controlPoints;
    float color[4];
    int type; // 0: Cardinal Spline, 1: MyBezier
} MyCurve;

std::vector<MyPoint> drawnPoints;
std::vector<MyLine> drawnLines;
std::vector<MyCircle> drawnCircles;
std::vector<MyEllipse> drawnEllipses;
std::vector<MyPolygon> drawnPolygons;
std::vector<MyCurve> drawnCurves;

// Temporary points for interactive drawing (e.g., first point of a line, center of circle)
std::vector<MyPoint> tempPoints;

// Mouse cursor related
bool showCustomCursor = true;
int customCursorShape = 0; // 0: default square, 1: cross, 2: circle

// Flood fill specific state
bool floodFillActive = false;

// --- Function Prototypes ---
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); // Window Procedure
GLvoid ReSizeGLScene(GLsizei width, GLsizei height); // Resize Function
GLint InitGL();                                      // Initialize OpenGL
GLvoid DrawGLScene();                                // Drawing Function

// Menu Command IDs (Arbitrary numbers, but keep them unique and above system commands)
#define IDM_COLOR_RED        1001
#define IDM_COLOR_GREEN      1002
#define IDM_COLOR_BLUE       1003
#define IDM_COLOR_BLACK      1004
#define IDM_COLOR_WHITE      1005
#define IDM_COLOR_YELLOW     1006
#define IDM_COLOR_CYAN       1007
#define IDM_COLOR_MAGENTA    1008

#define IDM_SHAPE_POINT      2001
#define IDM_SHAPE_LINE       2002
#define IDM_SHAPE_CIRCLE     2003
#define IDM_SHAPE_ELLIPSE    2004
#define IDM_SHAPE_POLYGON    2005
#define IDM_SHAPE_CARDINAL   2006
#define IDM_SHAPE_BEZIER     2007

#define IDM_LINE_DDA         3001
#define IDM_LINE_MIDPOINT    3002
#define IDM_LINE_PARAMETRIC  3003

#define IDM_CIRCLE_DIRECT    4001
#define IDM_CIRCLE_POLAR     4002
#define IDM_CIRCLE_ITERATIVE 4003
#define IDM_CIRCLE_MIDPOINT  4004
#define IDM_CIRCLE_MODIFIED  4005

#define IDM_ELLIPSE_DIRECT   5001
#define IDM_ELLIPSE_POLAR    5002
#define IDM_ELLIPSE_MIDPOINT 5003

#define IDM_FILL_CIRCLE_Q1   6001
#define IDM_FILL_CIRCLE_Q2   6002
#define IDM_FILL_CIRCLE_Q3   6003
#define IDM_FILL_CIRCLE_Q4   6004
#define IDM_FILL_CIRCLE_LINES 6005
#define IDM_FILL_CIRCLE_CIRCLES 6006
#define IDM_FILL_CIRCLE_NONE 6007

#define IDM_FILL_SQUARE      6100 // Conceptual
#define IDM_FILL_RECTANGLE   6101 // Conceptual

#define IDM_POLYGON_CONVEX   6201
#define IDM_POLYGON_NONCONVEX 6202

#define IDM_FLOOD_RECURSIVE  6301
#define IDM_FLOOD_NONRECURSIVE 6302

#define IDM_CLIP_ENABLE      7001
#define IDM_CLIP_DISABLE     7002
#define IDM_CLIP_SETWINDOW   7003

#define IDM_CLIP_TYPE_POINT    7101
#define IDM_CLIP_TYPE_LINE     7102
#define IDM_CLIP_TYPE_POLYGON  7103

#define IDM_CLIP_WINDOW_RECTANGLE 7201
#define IDM_CLIP_WINDOW_SQUARE 7202

#define IDM_CURSOR_DEFAULT   8001
#define IDM_CURSOR_SQUARE    8002
#define IDM_CURSOR_CROSS     8003
#define IDM_CURSOR_CIRCLE    8004

#define IDM_FILE_CLEAR       9001
#define IDM_FILE_SAVE        9002
#define IDM_FILE_LOAD        9003
#define IDM_EXIT             9004

// --- Utility Functions ---

// Function to set a pixel at (x, y) with the current global color
void setPixel(int x, int y) {
    glBegin(GL_POINTS);
    glColor3fv(currentColor); // Use the current global drawing color
    glVertex2i(x, y);
    glEnd();
}

// Function to set a pixel at (x, y) with a specified color
void setPixel(int x, int y, const float color[4]) {
    glBegin(GL_POINTS);
    glColor4fv(color); // Use the specified color (includes alpha)
    glVertex2i(x, y);
    glEnd();
}

// Function to read a pixel's color (basic, for flood fill)
// Note: glReadPixels can be slow. For interactive apps, it's generally avoided
// for per-pixel operations. Here, it's used for flood fill's boundary check.
void getPixel(int x, int y, float color[4]) {
    // Ensure the pixel is within window bounds before reading
    if (x >= 0 && x < windowWidth && y >= 0 && y < windowHeight) {
        glReadPixels(x, y, 1, 1, GL_RGBA, GL_FLOAT, color);
    }
    else {
        // Return a distinct color if out of bounds to act as a boundary
        color[0] = -1.0f; color[1] = -1.0f; color[2] = -1.0f; color[3] = -1.0f;
    }
}

// --- Drawing Algorithms ---

// DDA Line Algorithm
void drawLineDDA(float x0, float y0, float x1, float y1) {
    float dx = x1 - x0;
    float dy = y1 - y0;
    float steps;
    float xIncrement, yIncrement;
    float x = x0, y = y0;

    steps = (fabs(dx) > fabs(dy)) ? fabs(dx) : fabs(dy);

    if (steps == 0) { // Handle single point case
        setPixel(round(x), round(y));
        return;
    }

    xIncrement = dx / steps;
    yIncrement = dy / steps;

    setPixel(round(x), round(y));

    for (int k = 0; k < steps; k++) {
        x += xIncrement;
        y += yIncrement;
        setPixel(round(x), round(y));
    }
}

// Midpoint Line Algorithm (Bresenham's)
void drawLineMidpoint(float x0, float y0, float x1, float y1) {
    int x_int0 = round(x0);
    int y_int0 = round(y0);
    int x_int1 = round(x1);
    int y_int1 = round(y1);

    int dx = abs(x_int1 - x_int0);
    int dy = abs(y_int1 - y_int0);
    int sx = x_int0 < x_int1 ? 1 : -1; // Step direction for x
    int sy = y_int0 < y_int1 ? 1 : -1; // Step direction for y
    int err = dx - dy; // Initial error term

    int x = x_int0, y = y_int0;

    while (true) {
        setPixel(x, y);
        if (x == x_int1 && y == y_int1) break; // Corrected typo here

        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x += sx;
        }
        if (e2 < dx) {
            err += dx;
            y += sy;
        }
    }
}

// Parametric Line Algorithm
void drawLineParametric(float x0, float y0, float x1, float y1) {
    for (float t = 0.0; t <= 1.0; t += 0.001) {
        float x = x0 + t * (x1 - x0);
        float y = y0 + t * (y1 - y0);
        setPixel(round(x), round(y));
    }
}

// Helper for Circle Algorithms (draws points in all 8 octants based on symmetry)
void drawCirclePoints(int xc, int yc, int x, int y) {
    setPixel(xc + x, yc + y);
    setPixel(xc - x, yc + y);
    setPixel(xc + x, yc - y);
    setPixel(xc - x, yc - y);
    setPixel(xc + y, yc + x);
    setPixel(xc - y, yc + x);
    setPixel(xc + y, yc - x);
    setPixel(xc - y, yc - x);
}

// Direct Circle Algorithm (uses equation of circle: x^2 + y^2 = r^2)
void drawCircleDirect(int xc, int yc, int r) {
    for (int x_offset = -r; x_offset <= r; x_offset++) {
        int y_sq = r * r - x_offset * x_offset;
        if (y_sq >= 0) {
            int y_offset = round(sqrt(y_sq));
            setPixel(xc + x_offset, yc + y_offset);
            setPixel(xc + x_offset, yc - y_offset);
        }
    }
    for (int y_offset = -r; y_offset <= r; y_offset++) {
        int x_sq = r * r - y_offset * y_offset;
        if (x_sq >= 0) {
            int x_offset = round(sqrt(x_sq));
            setPixel(xc + x_offset, yc + y_offset);
            setPixel(xc - x_offset, yc + y_offset);
        }
    }
}

// Polar Circle Algorithm (uses trigonometric functions)
void drawCirclePolar(int xc, int yc, int r) {
    for (float angle = 0; angle <= M_PI_4 + 0.0001; angle += 0.001) {
        int x = round(r * cos(angle));
        int y = round(r * sin(angle));
        drawCirclePoints(xc, yc, x, y);
    }
}

// Iterative Polar Circle Algorithm (simplified, similar to Polar but with fixed angle step)
void drawCircleIterativePolar(int xc, int yc, int r) {
    float delta_theta = 1.0f / r;
    if (delta_theta > M_PI_4) delta_theta = M_PI_4 / 100.0f;

    for (float angle = 0; angle <= M_PI_4 + delta_theta; angle += delta_theta) {
        int x = round(r * cos(angle));
        int y = round(r * sin(angle));
        drawCirclePoints(xc, yc, x, y);
    }
}

// Midpoint Circle Algorithm (Bresenham's Circle Algorithm)
void drawCircleMidpoint(int xc, int yc, int r) {
    int x = 0;
    int y = r;
    int p = 1 - r;

    drawCirclePoints(xc, yc, x, y);

    while (x < y) {
        x++;
        if (p < 0) {
            p = p + 2 * x + 1;
        }
        else {
            y--;
            p = p + 2 * x + 1 - 2 * y;
        }
        drawCirclePoints(xc, yc, x, y);
    }
}

// Modified Midpoint Circle Algorithm
void drawCircleModifiedMidpoint(int xc, int yc, int r) {
    int x = 0;
    int y = r;
    float p = 5.0 / 4.0 - r;

    drawCirclePoints(xc, yc, x, y);

    while (x < y) {
        x++;
        if (p < 0) {
            p += 2.0 * x + 1.0;
        }
        else {
            y--;
            p += 2.0 * (x - y) + 1.0;
        }
        drawCirclePoints(xc, yc, x, y);
    }
}

// --- Ellipse Algorithms ---

// Helper for Ellipse Algorithms (draws points in all 4 quadrants based on symmetry)
void drawEllipsePoints(int xc, int yc, int x, int y) {
    setPixel(xc + x, yc + y);
    setPixel(xc - x, yc + y);
    setPixel(xc + x, yc - y);
    setPixel(xc - x, yc - y);
}

// Direct Ellipse Algorithm (uses equation of ellipse)
void drawEllipseDirect(int xc, int yc, int rx, int ry) {
    long long rx_sq = (long long)rx * rx;
    long long ry_sq = (long long)ry * ry;

    for (int x = 0; x <= rx; x++) {
        long long y_sq = ry_sq * (rx_sq - (long long)x * x) / rx_sq;
        int y = round(sqrt(y_sq));
        drawEllipsePoints(xc, yc, x, y);
    }

    for (int y = 0; y <= ry; y++) {
        long long x_sq = rx_sq * (ry_sq - (long long)y * y) / ry_sq;
        int x = round(sqrt(x_sq));
        drawEllipsePoints(xc, yc, x, y);
    }
}

// Polar Ellipse Algorithm (uses trigonometric functions)
void drawEllipsePolar(int xc, int yc, int rx, int ry) {
    for (float angle = 0; angle <= M_PI_2 + 0.0001; angle += 0.001) {
        int x = round(rx * cos(angle));
        int y = round(ry * sin(angle));
        drawEllipsePoints(xc, yc, x, y);
    }
}

// Midpoint Ellipse Algorithm (Bresenham's Ellipse Algorithm)
void drawEllipseMidpoint(int xc, int yc, int rx, int ry) {
    long long rx_sq = (long long)rx * rx;
    long long ry_sq = (long long)ry * ry;
    long long two_rx_sq = 2 * rx_sq;
    long long two_ry_sq = 2 * ry_sq;
    int x = 0;
    int y = ry;
    long long px = 0;
    long long py = two_rx_sq * y;

    // Region 1: dx/dy < 1 (slope < 1)
    long long p1 = round(ry_sq - rx_sq * ry + 0.25 * rx_sq);
    while (px < py) {
        drawEllipsePoints(xc, yc, x, y);
        x++;
        px += two_ry_sq;
        if (p1 < 0) {
            p1 += py + ry_sq;
        }
        else {
            y--;
            py -= two_rx_sq;
            p1 += py - px + ry_sq;
        }
    }

    // Region 2: dx/dy > 1 (slope > 1)
    long long p2 = round(ry_sq * (x + 0.5) * (x + 0.5) + rx_sq * (y - 1) * (y - 1) - rx_sq * ry_sq);
    while (y >= 0) {
        drawEllipsePoints(xc, yc, x, y);
        y--;
        py -= two_rx_sq;
        if (p2 > 0) {
            p2 += rx_sq - py;
        }
        else {
            x++;
            px += two_ry_sq;
            p2 += px + rx_sq - py;
        }
    }
}

// --- Curve Algorithms ---

// Cardinal Spline Curve
void drawCardinalSpline(const std::vector<MyPoint>& controlPoints, float tension) {
    if (controlPoints.size() < 4) {
        return;
    }

    float s = (1.0f - tension) / 2.0f;

    for (size_t i = 1; i < controlPoints.size() - 2; ++i) {
        const MyPoint& p0 = controlPoints[i - 1];
        const MyPoint& p1 = controlPoints[i];
        const MyPoint& p2 = controlPoints[i + 1];
        const MyPoint& p3 = controlPoints[i + 2];

        for (float t = 0.0f; t <= 1.0f; t += 0.01f) {
            float t2 = t * t;
            float t3 = t2 * t;

            float h1 = -s * t3 + 2 * s * t2 - s * t;
            float h2 = (2 - s) * t3 + (s - 3) * t2 + 1;
            float h3 = (-2 + s) * t3 + (3 - 2 * s) * t2 + s * t;
            float h4 = s * t3 - s * t2;

            float x = h1 * p0.x + h2 * p1.x + h3 * p2.x + h4 * p3.x;
            float y = h1 * p0.y + h2 * p1.y + h3 * p2.y + h4 * p3.y;

            setPixel(round(x), round(y));
        }
    }
}


// Bezier Curve (Cubic, using 4 control points)
void drawBezierCurve(const std::vector<MyPoint>& controlPoints) {
    if (controlPoints.size() != 4) {
        return;
    }

    const MyPoint& p0 = controlPoints[0];
    const MyPoint& p1 = controlPoints[1];
    const MyPoint& p2 = controlPoints[2];
    const MyPoint& p3 = controlPoints[3];

    for (float t = 0.0f; t <= 1.0f; t += 0.01f) {
        float one_minus_t = 1.0f - t;
        float one_minus_t_sq = one_minus_t * one_minus_t;
        float one_minus_t_cub = one_minus_t_sq * one_minus_t;

        float t_sq = t * t;
        float t_cub = t_sq * t;

        float x = one_minus_t_cub * p0.x +
            3 * one_minus_t_sq * t * p1.x +
            3 * one_minus_t * t_sq * p2.x +
            t_cub * p3.x;

        float y = one_minus_t_cub * p0.y +
            3 * one_minus_t_sq * t * p1.y +
            3 * one_minus_t * t_sq * p2.y +
            t_cub * p3.y;

        setPixel(round(x), round(y));
    }
}


// --- Filling Algorithms ---

// Recursive Flood Fill
void floodFillRecursive(int x, int y, const float newColor[4], const float oldColor[4]) {
    float pixelColor[4];
    getPixel(x, y, pixelColor);

    if (x >= 0 && x < windowWidth && y >= 0 && y < windowHeight &&
        fabs(pixelColor[0] - oldColor[0]) < 0.01 &&
        fabs(pixelColor[1] - oldColor[1]) < 0.01 &&
        fabs(pixelColor[2] - oldColor[2]) < 0.01 &&
        fabs(pixelColor[3] - oldColor[3]) < 0.01)
    {
        setPixel(x, y, newColor);
        floodFillRecursive(x + 1, y, newColor, oldColor);
        floodFillRecursive(x - 1, y, newColor, oldColor);
        floodFillRecursive(x, y + 1, newColor, oldColor);
        floodFillRecursive(x, y - 1, newColor, oldColor);
    }
}

// Non-Recursive Flood Fill (using a stack to avoid recursion depth limits)
void floodFillNonRecursive(int x, int y, const float newColor[4], const float oldColor[4]) {
    std::vector<MyPoint> stack;
    stack.push_back({ (float)x, (float)y });

    float pixelColor[4];

    while (!stack.empty()) {
        MyPoint current = stack.back();
        stack.pop_back();

        int currX = round(current.x);
        int currY = round(current.y);

        getPixel(currX, currY, pixelColor);

        if (currX >= 0 && currX < windowWidth && currY >= 0 && currY < windowHeight &&
            fabs(pixelColor[0] - oldColor[0]) < 0.01 &&
            fabs(pixelColor[1] - oldColor[1]) < 0.01 &&
            fabs(pixelColor[2] - oldColor[2]) < 0.01 &&
            fabs(pixelColor[3] - oldColor[3]) < 0.01)
        {
            setPixel(currX, currY, newColor);

            stack.push_back({ (float)(currX + 1), (float)currY });
            stack.push_back({ (float)(currX - 1), (float)currY });
            stack.push_back({ (float)currX, (float)(currY + 1) });
            stack.push_back({ (float)currX, (float)(currY - 1) });
        }
    }
}

// Filling Circle with horizontal lines
void fillCircleWithLines(int xc, int yc, int r, int quarter) {
    for (int y_offset = -r; y_offset <= r; ++y_offset) {
        int x_span = round(sqrt(r * r - y_offset * y_offset));
        int y_current = yc + y_offset;
        int x_start = xc - x_span;
        int x_end = xc + x_span;

        if (quarter == 1) { // Top-Right (x >= xc, y >= yc)
            if (y_current >= yc) drawLineDDA(max(x_start, xc), y_current, x_end, y_current);
        }
        else if (quarter == 2) { // Top-Left (x <= xc, y >= yc)
            if (y_current >= yc) drawLineDDA(x_start, y_current, min(x_end, xc), y_current);
        }
        else if (quarter == 3) { // Bottom-Left (x <= xc, y <= yc)
            if (y_current <= yc) drawLineDDA(x_start, y_current, min(x_end, xc), y_current);
        }
        else if (quarter == 4) { // Bottom-Right (x >= xc, y <= yc)
            if (y_current <= yc) drawLineDDA(max(x_start, xc), y_current, x_end, y_current);
        }
        else { // quarter == 0 or other: Full circle fill
            drawLineDDA(x_start, y_current, x_end, y_current);
        }
    }
}

// Filling Circle with concentric circles
void fillCircleWithCircles(int xc, int yc, int r, int quarter) {
    for (int current_r = r; current_r >= 1; current_r -= 2) {
        if (quarter == 1) { // Top-Right (0 to 90 degrees)
            for (float angle = 0; angle <= M_PI_2; angle += 0.01) {
                int x_offset = round(current_r * cos(angle));
                int y_offset = round(current_r * sin(angle));
                setPixel(xc + x_offset, yc + y_offset);
            }
        }
        else if (quarter == 2) { // Top-Left (90 to 180 degrees)
            for (float angle = M_PI_2; angle <= M_PI; angle += 0.01) {
                int x_offset = round(current_r * cos(angle));
                int y_offset = round(current_r * sin(angle));
                setPixel(xc + x_offset, yc + y_offset);
            }
        }
        else if (quarter == 3) { // Bottom-Left (180 to 270 degrees)
            for (float angle = M_PI; angle <= 3 * M_PI_2; angle += 0.01) {
                int x_offset = round(current_r * cos(angle));
                int y_offset = round(current_r * sin(angle));
                setPixel(xc + x_offset, yc + y_offset);
            }
        }
        else if (quarter == 4) { // Bottom-Right (270 to 360 degrees)
            for (float angle = 3 * M_PI_2; angle <= 2 * M_PI; angle += 0.01) {
                int x_offset = round(current_r * cos(angle));
                int y_offset = round(current_r * sin(angle));
                setPixel(xc + x_offset, yc + y_offset);
            }
        }
        else { // quarter == 0 or other: Full circle fill
            drawCircleMidpoint(xc, yc, current_r);
        }
    }
}

// Simplified MyPolygon Fill (Scanline approach)
void drawPolygonFill(const std::vector<MyPoint>& vertices) {
    if (vertices.empty()) return;

    int minY = vertices[0].y, maxY = vertices[0].y;
    for (const auto& p : vertices) {
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
    }

    for (int y = minY; y <= maxY; ++y) {
        std::vector<int> intersections;

        for (size_t i = 0; i < vertices.size(); ++i) {
            const MyPoint& p1 = vertices[i];
            const MyPoint& p2 = vertices[(i + 1) % vertices.size()];

            if ((p1.y <= y && p2.y > y) || (p2.y <= y && p1.y > y)) {
                if (p1.y == p2.y) continue; // Skip horizontal lines to avoid division by zero or duplicates

                float x_intersect = p1.x + (float)(y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
                intersections.push_back(round(x_intersect));
            }
        }

        std::sort(intersections.begin(), intersections.end());

        // Fill pixels between pairs of intersection points
        for (size_t i = 0; i + 1 < intersections.size(); i += 2) {
            drawLineDDA(intersections[i], y, intersections[i + 1], y);
        }
    }
}


// --- Clipping Algorithms ---

// MyPoint Clipping: Checks if a point (x, y) is inside the clipping window.
bool clipPoint(float x, float y, float xmin, float ymin, float xmax, float ymax) {
    return (x >= xmin && x <= xmax && y >= ymin && y <= ymax);
}

// Cohen-Sutherland Line Clipping (simplified version)
void clipLineCohenSutherland(float x0, float y0, float x1, float y1, float xmin, float ymin, float xmax, float ymax) {
    if (clipPoint(x0, y0, xmin, ymin, xmax, ymax) &&
        clipPoint(x1, y1, xmin, ymin, xmax, ymax)) {
        drawLineDDA(x0, y0, x1, y1);
    }
    else {
        // Not drawn if not fully inside.
    }
}

// Sutherland-Hodgman MyPolygon Clipping
std::vector<MyPoint> clipPolygonSutherlandHodgman(const std::vector<MyPoint>& inputPolygon,
    float xmin, float ymin, float xmax, float ymax) {
    std::vector<MyPoint> outputList = inputPolygon;

    struct ClipEdge {
        float normalX, normalY;
        float boundaryValue;
    };
    std::vector<ClipEdge> clipEdges = {
        {-1.0f, 0.0f, -xmin}, // Left edge
        { 1.0f, 0.0f,  xmax}, // Right edge
        { 0.0f,-1.0f, -ymin}, // Bottom edge
        { 0.0f, 1.0f,  ymax}  // Top edge
    };

    for (const auto& edge : clipEdges) {
        std::vector<MyPoint> tempOutput;
        if (outputList.empty()) break;

        for (size_t i = 0; i < outputList.size(); ++i) {
            MyPoint p1 = outputList[i];
            MyPoint p2 = outputList[(i + 1) % outputList.size()];

            bool p1_inside = (edge.normalX * p1.x + edge.normalY * p1.y <= edge.boundaryValue);
            bool p2_inside = (edge.normalX * p2.x + edge.normalY * p2.y <= edge.boundaryValue);

            if (p1_inside && p2_inside) {
                tempOutput.push_back(p2);
            }
            else if (!p1_inside && p2_inside) {
                float dx = p2.x - p1.x;
                float dy = p2.y - p1.y;
                float t = 0.0f;

                if (fabs(edge.normalX) > 0.01) {
                    t = (edge.boundaryValue / edge.normalX - p1.x) / dx;
                }
                else {
                    t = (edge.boundaryValue / edge.normalY - p1.y) / dy;
                }
                MyPoint intersect_pt = { p1.x + t * dx, p1.y + t * dy }; // No color on temp point needed
                // Copy color from p1 or p2, depending on how you want the clipped edge to look
                std::copy(p2.color, p2.color + 4, intersect_pt.color);
                tempOutput.push_back(intersect_pt);
                tempOutput.push_back(p2);
            }
            else if (p1_inside && !p2_inside) {
                float dx = p2.x - p1.x;
                float dy = p2.y - p1.y;
                float t = 0.0f;

                if (fabs(edge.normalX) > 0.01) {
                    t = (edge.boundaryValue / edge.normalX - p1.x) / dx;
                }
                else {
                    t = (edge.boundaryValue / edge.normalY - p1.y) / dy;
                }
                MyPoint intersect_pt = { p1.x + t * dx, p1.y + t * dy };
                std::copy(p1.color, p1.color + 4, intersect_pt.color);
                tempOutput.push_back(intersect_pt);
            }
        }
        outputList = tempOutput;
    }

    return outputList;
}


// --- Save/Load Functions ---

void saveData(const std::string& filename) {
    std::ofstream outFile(filename);
    if (!outFile.is_open()) {
        std::cerr << "Error: Could not open file " << filename << " for saving.\n";
        return;
    }

    outFile << "POINTS\n";
    for (const auto& p_obj : drawnPoints) { // Renamed loop variable
        outFile << p_obj.x << "," << p_obj.y << "," << p_obj.color[0] << "," << p_obj.color[1] << "," << p_obj.color[2] << "," << p_obj.color[3] << "\n";
    }

    outFile << "LINES\n";
    for (const auto& l_obj : drawnLines) { // Renamed loop variable
        outFile << l_obj.x0 << "," << l_obj.y0 << "," << l_obj.x1 << "," << l_obj.y1 << ","
            << l_obj.color[0] << "," << l_obj.color[1] << "," << l_obj.color[2] << "," << l_obj.color[3] << ","
            << l_obj.algorithm << "\n";
    }

    outFile << "CIRCLES\n";
    for (const auto& c_obj : drawnCircles) { // Renamed loop variable
        outFile << c_obj.xc << "," << c_obj.yc << "," << c_obj.r << ","
            << c_obj.color[0] << "," << c_obj.color[1] << "," << c_obj.color[2] << "," << c_obj.color[3] << ","
            << c_obj.algorithm << "," << c_obj.fillMode << "," << c_obj.fillQuarter << "\n";
    }

    outFile << "ELLIPSES\n";
    for (const auto& e_obj : drawnEllipses) {
        outFile << e_obj.xc << "," << e_obj.yc << "," << e_obj.rx << "," << e_obj.ry << ","
            << e_obj.color[0] << "," << e_obj.color[1] << "," << e_obj.color[2] << "," << e_obj.color[3] << ","
            << e_obj.algorithm << "\n";
    }

    outFile << "POLYGONS\n";
    for (const auto& poly_obj : drawnPolygons) {
        outFile << poly_obj.vertices.size() << ","; // Store number of vertices
        for (const auto& p_vert : poly_obj.vertices) { // Renamed loop variable
            outFile << p_vert.x << "," << p_vert.y << ",";
        }
        outFile << poly_obj.color[0] << "," << poly_obj.color[1] << "," << poly_obj.color[2] << "," << poly_obj.color[3] << "\n";
    }

    outFile << "CURVES\n";
    for (const auto& curve_obj : drawnCurves) {
        outFile << curve_obj.type << ",";
        outFile << curve_obj.controlPoints.size() << ","; // Store number of control points
        for (const auto& p_ctrl : curve_obj.controlPoints) { // Renamed loop variable
            outFile << p_ctrl.x << "," << p_ctrl.y << ",";
        }
        outFile << curve_obj.color[0] << "," << curve_obj.color[1] << "," << curve_obj.color[2] << "," << curve_obj.color[3] << "\n";
    }

    outFile.close();
    std::cout << "Drawing data saved to " << filename << std::endl;
}

void loadData(const std::string& filename) {
    std::ifstream inFile(filename);
    if (!inFile.is_open()) {
        std::cerr << "Error: Could not open file " << filename << " for loading.\n";
        return;
    }

    drawnPoints.clear();
    drawnLines.clear();
    drawnCircles.clear();
    drawnEllipses.clear();
    drawnPolygons.clear();
    drawnCurves.clear();
    tempPoints.clear();
    drawingMode = 0;

    std::string line;
    std::string currentSection;

    while (std::getline(inFile, line)) {
        if (line == "POINTS" || line == "LINES" || line == "CIRCLES" ||
            line == "ELLIPSES" || line == "POLYGONS" || line == "CURVES") {
            currentSection = line;
            continue;
        }

        std::stringstream ss(line);
        std::string segment;

        if (currentSection == "POINTS") {
            MyPoint p_obj; // Use MyPoint
            std::getline(ss, segment, ','); p_obj.x = std::stof(segment);
            std::getline(ss, segment, ','); p_obj.y = std::stof(segment);
            std::getline(ss, segment, ','); p_obj.color[0] = std::stof(segment);
            std::getline(ss, segment, ','); p_obj.color[1] = std::stof(segment);
            std::getline(ss, segment, ','); p_obj.color[2] = std::stof(segment);
            std::getline(ss, segment, '\n'); p_obj.color[3] = std::stof(segment);
            drawnPoints.push_back(p_obj);
        }
        else if (currentSection == "LINES") {
            MyLine l_obj; // Use MyLine
            std::getline(ss, segment, ','); l_obj.x0 = std::stof(segment);
            std::getline(ss, segment, ','); l_obj.y0 = std::stof(segment);
            std::getline(ss, segment, ','); l_obj.x1 = std::stof(segment);
            std::getline(ss, segment, ','); l_obj.y1 = std::stof(segment);
            std::getline(ss, segment, ','); l_obj.color[0] = std::stof(segment);
            std::getline(ss, segment, ','); l_obj.color[1] = std::stof(segment);
            std::getline(ss, segment, ','); l_obj.color[2] = std::stof(segment);
            std::getline(ss, segment, ','); l_obj.color[3] = std::stof(segment);
            std::getline(ss, segment, '\n'); l_obj.algorithm = std::stoi(segment);
            drawnLines.push_back(l_obj);
        }
        else if (currentSection == "CIRCLES") {
            MyCircle c_obj; // Use MyCircle
            std::getline(ss, segment, ','); c_obj.xc = std::stof(segment);
            std::getline(ss, segment, ','); c_obj.yc = std::stof(segment);
            std::getline(ss, segment, ','); c_obj.r = std::stof(segment);
            std::getline(ss, segment, ','); c_obj.color[0] = std::stof(segment);
            std::getline(ss, segment, ','); c_obj.color[1] = std::stof(segment);
            std::getline(ss, segment, ','); c_obj.color[2] = std::stof(segment);
            std::getline(ss, segment, ','); c_obj.color[3] = std::stof(segment);
            std::getline(ss, segment, ','); c_obj.algorithm = std::stoi(segment);
            std::getline(ss, segment, ','); c_obj.fillMode = std::stoi(segment);
            std::getline(ss, segment, '\n'); c_obj.fillQuarter = std::stoi(segment);
            drawnCircles.push_back(c_obj);
        }
        else if (currentSection == "ELLIPSES") {
            MyEllipse e_obj;
            std::getline(ss, segment, ','); e_obj.xc = std::stof(segment);
            std::getline(ss, segment, ','); e_obj.yc = std::stof(segment);
            std::getline(ss, segment, ','); e_obj.rx = std::stof(segment);
            std::getline(ss, segment, ','); e_obj.ry = std::stof(segment);
            std::getline(ss, segment, ','); e_obj.color[0] = std::stof(segment);
            std::getline(ss, segment, ','); e_obj.color[1] = std::stof(segment);
            std::getline(ss, segment, ','); e_obj.color[2] = std::stof(segment);
            std::getline(ss, segment, ','); e_obj.color[3] = std::stof(segment);
            std::getline(ss, segment, '\n'); e_obj.algorithm = std::stoi(segment);
            drawnEllipses.push_back(e_obj);
        }
        else if (currentSection == "POLYGONS") {
            MyPolygon poly_obj;
            int num_vertices;
            std::getline(ss, segment, ','); num_vertices = std::stoi(segment);
            poly_obj.vertices.clear();
            for (int i = 0; i < num_vertices; ++i) {
                MyPoint p_vert; // Use MyPoint
                std::getline(ss, segment, ','); p_vert.x = std::stof(segment);
                std::getline(ss, segment, ','); p_vert.y = std::stof(segment);
                poly_obj.vertices.push_back(p_vert);
            }
            std::getline(ss, segment, ','); poly_obj.color[0] = std::stof(segment);
            std::getline(ss, segment, ','); poly_obj.color[1] = std::stof(segment);
            std::getline(ss, segment, ','); poly_obj.color[2] = std::stof(segment);
            std::getline(ss, segment, '\n'); poly_obj.color[3] = std::stof(segment);
            drawnPolygons.push_back(poly_obj);
        }
        else if (currentSection == "CURVES") {
            MyCurve curve_obj;
            int num_control_points;
            std::getline(ss, segment, ','); curve_obj.type = std::stoi(segment);
            std::getline(ss, segment, ','); num_control_points = std::stoi(segment);
            curve_obj.controlPoints.clear();
            for (int i = 0; i < num_control_points; ++i) {
                MyPoint p_ctrl; // Use MyPoint
                std::getline(ss, segment, ','); p_ctrl.x = std::stof(segment);
                std::getline(ss, segment, ','); p_ctrl.y = std::stof(segment);
                curve_obj.controlPoints.push_back(p_ctrl);
            }
            std::getline(ss, segment, ','); curve_obj.color[0] = std::stof(segment);
            std::getline(ss, segment, ','); curve_obj.color[1] = std::stof(segment);
            std::getline(ss, segment, ','); curve_obj.color[2] = std::stof(segment);
            std::getline(ss, segment, '\n'); curve_obj.color[3] = std::stof(segment);
            drawnCurves.push_back(curve_obj);
        }
    }

    inFile.close();
    std::cout << "Drawing data loaded from " << filename << std::endl;
    InvalidateRect(hWnd, NULL, FALSE); // Request redraw to display loaded data
}

// --- Custom Cursor Drawing ---
// Draws the selected custom cursor shape at the current mouse position
void drawCustomCursor(int x, int y) {
    glColor3f(0.0, 0.0, 1.0); // Blue color for the cursor
    glPointSize(1.0);

    if (customCursorShape == 0) { // Square cursor
        glBegin(GL_LINE_LOOP);
        glVertex2i(x - 5, y - 5);
        glVertex2i(x + 5, y - 5);
        glVertex2i(x + 5, y + 5);
        glVertex2i(x - 5, y + 5);
        glEnd();
    }
    else if (customCursorShape == 1) { // Cross cursor
        glBegin(GL_LINES);
        glVertex2i(x - 8, y);
        glVertex2i(x + 8, y);
        glVertex2i(x, y - 8);
        glVertex2i(x, y + 8);
        glEnd();
    }
    else if (customCursorShape == 2) { // Circle cursor
        float radius = 7.0f;
        glBegin(GL_LINE_LOOP);
        for (int i = 0; i < 360; i++) {
            float angle = i * M_PI / 180.0f;
            glVertex2f(x + radius * cos(angle), y + radius * sin(angle));
        }
        glEnd();
    }
}

// --- OpenGL Initialization ---
GLint InitGL() {
    glShadeModel(GL_SMOOTH);
    glClearColor(1.0f, 1.0f, 1.0f, 1.0f); // White background
    glClearDepth(1.0f);
    glDisable(GL_DEPTH_TEST); // 2D drawing, depth test not needed
    glEnable(GL_BLEND); // Enable blending for smoother lines/points
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST); // Enable line antialiasing
    glEnable(GL_POINT_SMOOTH); // Enable point antialiasing

    ReSizeGLScene(windowWidth, windowHeight); // Set up the perspective

    return TRUE; // Initialization went OK
}

// --- OpenGL Reshape (Window Resize) ---
GLvoid ReSizeGLScene(GLsizei width, GLsizei height) {
    if (height == 0) height = 1;
    windowWidth = width;
    windowHeight = height;

    glViewport(0, 0, width, height); // Reset The Current Viewport

    glMatrixMode(GL_PROJECTION); // Select The Projection Matrix
    glLoadIdentity(); // Reset The Projection Matrix

    // Set up a 2D orthographic projection
    // (left, right, bottom, top)
    // (0,0) is bottom-left, (windowWidth, windowHeight) is top-right
    gluOrtho2D(0, (GLdouble)width, 0, (GLdouble)height);

    glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix
    glLoadIdentity(); // Reset The Modelview Matrix
}

// --- OpenGL Drawing Scene ---
GLvoid DrawGLScene() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear Screen And Depth Buffer
    glLoadIdentity(); // Reset The Current Modelview Matrix

    glPointSize(2.0);

    for (const auto& p_obj : drawnPoints) { // Using p_obj
        if (clippingEnabled && clippingType == 0) {
            if (clipPoint(p_obj.x, p_obj.y, clipWindowMinX, clipWindowMinY, clipWindowMaxX, clipWindowMaxY)) {
                setPixel(p_obj.x, p_obj.y, p_obj.color);
            }
        }
        else {
            setPixel(p_obj.x, p_obj.y, p_obj.color);
        }
    }

    for (const auto& l_obj : drawnLines) { // Using l_obj
        glColor4fv(l_obj.color);
        if (clippingEnabled && clippingType == 1) {
            clipLineCohenSutherland(l_obj.x0, l_obj.y0, l_obj.x1, l_obj.y1, clipWindowMinX, clipWindowMinY, clipWindowMaxX, clipWindowMaxY);
        }
        else {
            switch (l_obj.algorithm) {
            case 0: drawLineDDA(l_obj.x0, l_obj.y0, l_obj.x1, l_obj.y1); break;
            case 1: drawLineMidpoint(l_obj.x0, l_obj.y0, l_obj.x1, l_obj.y1); break;
            case 2: drawLineParametric(l_obj.x0, l_obj.y0, l_obj.x1, l_obj.y1); break;
            }
        }
    }

    for (const auto& c_obj : drawnCircles) { // Using c_obj
        glColor4fv(c_obj.color);
        switch (c_obj.algorithm) {
        case 0: drawCircleDirect(c_obj.xc, c_obj.yc, c_obj.r); break;
        case 1: drawCirclePolar(c_obj.xc, c_obj.yc, c_obj.r); break;
        case 2: drawCircleIterativePolar(c_obj.xc, c_obj.yc, c_obj.r); break;
        case 3: drawCircleMidpoint(c_obj.xc, c_obj.yc, c_obj.r); break;
        case 4: drawCircleModifiedMidpoint(c_obj.xc, c_obj.yc, c_obj.r); break;
        }
        if (c_obj.fillMode == 1) {
            glColor4fv(c_obj.color);
            fillCircleWithLines(c_obj.xc, c_obj.yc, c_obj.r, c_obj.fillQuarter);
        }
        else if (c_obj.fillMode == 2) {
            glColor4fv(c_obj.color);
            fillCircleWithCircles(c_obj.xc, c_obj.yc, c_obj.r, c_obj.fillQuarter);
        }
    }

    for (const auto& e_obj : drawnEllipses) {
        glColor4fv(e_obj.color);
        switch (e_obj.algorithm) {
        case 0: drawEllipseDirect(e_obj.xc, e_obj.yc, e_obj.rx, e_obj.ry); break;
        case 1: drawEllipsePolar(e_obj.xc, e_obj.yc, e_obj.rx, e_obj.ry); break;
        case 2: drawEllipseMidpoint(e_obj.xc, e_obj.yc, e_obj.rx, e_obj.ry); break;
        }
    }

    for (const auto& poly_obj : drawnPolygons) {
        glColor4fv(poly_obj.color);
        if (poly_obj.vertices.size() > 1) {
            std::vector<MyPoint> displayedVertices = poly_obj.vertices;
            if (clippingEnabled && clippingType == 2) {
                displayedVertices = clipPolygonSutherlandHodgman(poly_obj.vertices, clipWindowMinX, clipWindowMinY, clipWindowMaxX, clipWindowMaxY);
            }

            glBegin(GL_LINE_LOOP);
            for (const auto& p_disp : displayedVertices) { // Using p_disp
                glVertex2f(p_disp.x, p_disp.y);
            }
            glEnd();

            drawPolygonFill(poly_obj.vertices);
        }
    }

    for (const auto& curve_obj : drawnCurves) {
        glColor4fv(curve_obj.color);
        if (curve_obj.type == 0) {
            drawCardinalSpline(curve_obj.controlPoints, 0.0f);
        }
        else if (curve_obj.type == 1) {
            drawBezierCurve(curve_obj.controlPoints);
        }
        glColor3f(1.0, 0.0, 0.0);
        glPointSize(5.0);
        glBegin(GL_POINTS);
        for (const auto& cp_obj : curve_obj.controlPoints) { // Using cp_obj
            glVertex2f(cp_obj.x, cp_obj.y);
        }
        glEnd();
        glPointSize(2.0);
    }

    // Draw temporary points
    glColor3fv(currentColor);
    glPointSize(5.0);
    glBegin(GL_POINTS);
    for (const auto& p_temp : tempPoints) { // Using p_temp
        glVertex2f(p_temp.x, p_temp.y);
    }
    glEnd();
    glPointSize(2.0);

    // Draw the clipping window outline
    if (clippingEnabled) {
        glColor3f(1.0, 0.0, 0.0);
        glBegin(GL_LINE_LOOP);
        glVertex2f(clipWindowMinX, clipWindowMinY);
        glVertex2f(clipWindowMaxX, clipWindowMinY);
        glVertex2f(clipWindowMaxX, clipWindowMaxY);
        glVertex2f(clipWindowMinX, clipWindowMaxY);
        glEnd();
    }

    // Draw the custom mouse cursor if enabled
    if (showCustomCursor) {
        drawCustomCursor(mouseX, mouseY);
    }

    SwapBuffers(hDC); // Swap the buffers (double buffering)
}

// --- Create Win32 Menu ---
HMENU CreateWin32Menu() {
    HMENU hMenuBar = CreateMenu();
    HMENU hSubMenu;

    // File Operations Menu
    hSubMenu = CreatePopupMenu();
    AppendMenu(hSubMenu, MF_STRING, IDM_FILE_CLEAR, TEXT("&Clear Screen"));
    AppendMenu(hSubMenu, MF_STRING, IDM_FILE_SAVE, TEXT("&Save Drawing"));
    AppendMenu(hSubMenu, MF_STRING, IDM_FILE_LOAD, TEXT("&Load Drawing"));
    AppendMenu(hSubMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hSubMenu, MF_STRING, IDM_EXIT, TEXT("E&xit"));
    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hSubMenu, TEXT("&File"));

    // Set Color Menu
    hSubMenu = CreatePopupMenu();
    AppendMenu(hSubMenu, MF_STRING, IDM_COLOR_RED, TEXT("Red"));
    AppendMenu(hSubMenu, MF_STRING, IDM_COLOR_GREEN, TEXT("Green"));
    AppendMenu(hSubMenu, MF_STRING, IDM_COLOR_BLUE, TEXT("Blue"));
    AppendMenu(hSubMenu, MF_STRING, IDM_COLOR_BLACK, TEXT("Black"));
    AppendMenu(hSubMenu, MF_STRING, IDM_COLOR_WHITE, TEXT("White"));
    AppendMenu(hSubMenu, MF_STRING, IDM_COLOR_YELLOW, TEXT("Yellow"));
    AppendMenu(hSubMenu, MF_STRING, IDM_COLOR_CYAN, TEXT("Cyan"));
    AppendMenu(hSubMenu, MF_STRING, IDM_COLOR_MAGENTA, TEXT("Magenta"));
    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hSubMenu, TEXT("&Set Color"));

    // Draw Shape Menu
    HMENU hLineAlgoMenu = CreatePopupMenu();
    AppendMenu(hLineAlgoMenu, MF_STRING, IDM_LINE_DDA, TEXT("DDA"));
    AppendMenu(hLineAlgoMenu, MF_STRING, IDM_LINE_MIDPOINT, TEXT("Midpoint (Bresenham)"));
    AppendMenu(hLineAlgoMenu, MF_STRING, IDM_LINE_PARAMETRIC, TEXT("Parametric"));

    HMENU hCircleAlgoMenu = CreatePopupMenu();
    AppendMenu(hCircleAlgoMenu, MF_STRING, IDM_CIRCLE_DIRECT, TEXT("Direct"));
    AppendMenu(hCircleAlgoMenu, MF_STRING, IDM_CIRCLE_POLAR, TEXT("Polar"));
    AppendMenu(hCircleAlgoMenu, MF_STRING, IDM_CIRCLE_ITERATIVE, TEXT("Iterative Polar"));
    AppendMenu(hCircleAlgoMenu, MF_STRING, IDM_CIRCLE_MIDPOINT, TEXT("Midpoint (Bresenham)"));
    AppendMenu(hCircleAlgoMenu, MF_STRING, IDM_CIRCLE_MODIFIED, TEXT("Modified Midpoint"));

    HMENU hEllipseAlgoMenu = CreatePopupMenu();
    AppendMenu(hEllipseAlgoMenu, MF_STRING, IDM_ELLIPSE_DIRECT, TEXT("Direct"));
    AppendMenu(hEllipseAlgoMenu, MF_STRING, IDM_ELLIPSE_POLAR, TEXT("Polar"));
    AppendMenu(hEllipseAlgoMenu, MF_STRING, IDM_ELLIPSE_MIDPOINT, TEXT("Midpoint (Bresenham)"));

    hSubMenu = CreatePopupMenu();
    AppendMenu(hSubMenu, MF_STRING, IDM_SHAPE_POINT, TEXT("Point"));
    AppendMenu(hSubMenu, MF_POPUP, (UINT_PTR)hLineAlgoMenu, TEXT("Line"));
    AppendMenu(hSubMenu, MF_POPUP, (UINT_PTR)hCircleAlgoMenu, TEXT("Circle"));
    AppendMenu(hSubMenu, MF_POPUP, (UINT_PTR)hEllipseAlgoMenu, TEXT("Ellipse"));
    AppendMenu(hSubMenu, MF_STRING, IDM_SHAPE_POLYGON, TEXT("Polygon"));
    AppendMenu(hSubMenu, MF_STRING, IDM_SHAPE_CARDINAL, TEXT("Cardinal Spline"));
    AppendMenu(hSubMenu, MF_STRING, IDM_SHAPE_BEZIER, TEXT("Bezier Curve"));
    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hSubMenu, TEXT("&Draw Shape"));

    // Fill Algorithms Menu
    HMENU hFillCircleMenu = CreatePopupMenu();
    AppendMenu(hFillCircleMenu, MF_STRING, IDM_FILL_CIRCLE_Q1, TEXT("Quarter 1 (Top-Right)"));
    AppendMenu(hFillCircleMenu, MF_STRING, IDM_FILL_CIRCLE_Q2, TEXT("Quarter 2 (Top-Left)"));
    AppendMenu(hFillCircleMenu, MF_STRING, IDM_FILL_CIRCLE_Q3, TEXT("Quarter 3 (Bottom-Left)"));
    AppendMenu(hFillCircleMenu, MF_STRING, IDM_FILL_CIRCLE_Q4, TEXT("Quarter 4 (Bottom-Right)"));
    AppendMenu(hFillCircleMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hFillCircleMenu, MF_STRING, IDM_FILL_CIRCLE_LINES, TEXT("Whole Circle (Lines)"));
    AppendMenu(hFillCircleMenu, MF_STRING, IDM_FILL_CIRCLE_CIRCLES, TEXT("Whole Circle (Circles)"));
    AppendMenu(hFillCircleMenu, MF_STRING, IDM_FILL_CIRCLE_NONE, TEXT("No Fill"));

    HMENU hPolygonFillMenu = CreatePopupMenu();
    AppendMenu(hPolygonFillMenu, MF_STRING, IDM_POLYGON_CONVEX, TEXT("Convex Fill (Current Implementation)"));
    AppendMenu(hPolygonFillMenu, MF_STRING, IDM_POLYGON_NONCONVEX, TEXT("Non-Convex Fill (Current Implementation)"));

    HMENU hFloodFillMenu = CreatePopupMenu();
    AppendMenu(hFloodFillMenu, MF_STRING, IDM_FLOOD_RECURSIVE, TEXT("Recursive Flood Fill (Click on area)"));
    AppendMenu(hFloodFillMenu, MF_STRING, IDM_FLOOD_NONRECURSIVE, TEXT("Non-Recursive Flood Fill (Click on area)"));

    hSubMenu = CreatePopupMenu();
    AppendMenu(hSubMenu, MF_POPUP, (UINT_PTR)hFillCircleMenu, TEXT("Fill Circle"));
    AppendMenu(hSubMenu, MF_STRING, IDM_FILL_SQUARE, TEXT("Fill Square (Hermite - Conceptual)"));
    AppendMenu(hSubMenu, MF_STRING, IDM_FILL_RECTANGLE, TEXT("Fill Rectangle (Bezier - Conceptual)"));
    AppendMenu(hSubMenu, MF_POPUP, (UINT_PTR)hPolygonFillMenu, TEXT("Polygon Filling"));
    AppendMenu(hSubMenu, MF_POPUP, (UINT_PTR)hFloodFillMenu, TEXT("Flood Fill"));
    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hSubMenu, TEXT("&Fill Algorithms"));

    // Clipping Menu
    HMENU hClippingTypeMenu = CreatePopupMenu();
    AppendMenu(hClippingTypeMenu, MF_STRING, IDM_CLIP_TYPE_POINT, TEXT("Clip Point"));
    AppendMenu(hClippingTypeMenu, MF_STRING, IDM_CLIP_TYPE_LINE, TEXT("Clip Line"));
    AppendMenu(hClippingTypeMenu, MF_STRING, IDM_CLIP_TYPE_POLYGON, TEXT("Clip Polygon"));

    HMENU hClippingWindowShapeMenu = CreatePopupMenu();
    AppendMenu(hClippingWindowShapeMenu, MF_STRING, IDM_CLIP_WINDOW_RECTANGLE, TEXT("Rectangle"));
    AppendMenu(hClippingWindowShapeMenu, MF_STRING, IDM_CLIP_WINDOW_SQUARE, TEXT("Square"));

    hSubMenu = CreatePopupMenu();
    AppendMenu(hSubMenu, MF_STRING, IDM_CLIP_ENABLE, TEXT("Enable Clipping"));
    AppendMenu(hSubMenu, MF_STRING, IDM_CLIP_DISABLE, TEXT("Disable Clipping"));
    AppendMenu(hSubMenu, MF_STRING, IDM_CLIP_SETWINDOW, TEXT("Set Clipping Window (Fixed)"));
    AppendMenu(hSubMenu, MF_POPUP, (UINT_PTR)hClippingTypeMenu, TEXT("Clipping Type"));
    AppendMenu(hSubMenu, MF_POPUP, (UINT_PTR)hClippingWindowShapeMenu, TEXT("Clipping Window Shape"));
    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hSubMenu, TEXT("&Clipping"));

    // Mouse Cursor Menu
    HMENU hCursorMenu = CreatePopupMenu();
    AppendMenu(hCursorMenu, MF_STRING, IDM_CURSOR_DEFAULT, TEXT("Default (System)"));
    AppendMenu(hCursorMenu, MF_STRING, IDM_CURSOR_SQUARE, TEXT("Custom Square"));
    AppendMenu(hCursorMenu, MF_STRING, IDM_CURSOR_CROSS, TEXT("Custom Cross"));
    AppendMenu(hCursorMenu, MF_STRING, IDM_CURSOR_CIRCLE, TEXT("Custom Circle"));
    AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hCursorMenu, TEXT("&Mouse Cursor"));

    return hMenuBar;
}

// --- Window Procedure (Main message handler) ---
LRESULT CALLBACK WndProc(HWND pHwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_CREATE:
    {
        // Initialize OpenGL context
        PIXELFORMATDESCRIPTOR pfd = {
            sizeof(PIXELFORMATDESCRIPTOR), 1,
            PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
            PFD_TYPE_RGBA, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, PFD_MAIN_PLANE, 0, 0, 0, 0
        };
        hDC = GetDC(pHwnd);
        if (!hDC) return FALSE;

        int pixelFormat = ChoosePixelFormat(hDC, &pfd);
        if (!pixelFormat) return FALSE;

        if (!SetPixelFormat(hDC, pixelFormat, &pfd)) return FALSE;

        hRC = wglCreateContext(hDC);
        if (!hRC) return FALSE;

        if (!wglMakeCurrent(hDC, hRC)) return FALSE;

        InitGL();
        std::cout << "Welcome to the Computer Graphics Drawing Program!\n";
        std::cout << "-----------------------------------------------\n";
        std::cout << "Instructions:\n";
        std::cout << "1. Use the top menu bar to access options.\n";
        std::cout << "2. Choose 'Set Color' to set the drawing color.\n";
        std::cout << "3. Choose 'Draw Shape' to select a shape type and its algorithm.\n";
        std::cout << "   - For MyPoints: Just click a single point.\n";
        std::cout << "   - For MyLines, MyCircles, MyEllipses: Follow the prompts in the console (e.g., click 2 points for a line).\n";
        std::cout << "   - For MyPolygons/Cardinal Splines: Click multiple control points, then right-click anywhere *outside* the menu to finish.\n";
        std::cout << "   - For MyBezier curves: Click exactly 4 control points.\n";
        std::cout << "4. 'Fill Algorithms' menu provides options for circle fills, polygon fills, and flood fill.\n";
        std::cout << "   - For Flood Fill: Select the option, then click on the area you want to fill.\n";
        std::cout << "5. 'Clipping' menu allows enabling/disabling clipping, setting the clipping type (MyPoint, MyLine, MyPolygon), and choosing window shape (Rectangle/Square).\n";
        std::cout << "   - Draw shapes *after* setting clipping options to see the effect.\n";
        std::cout << "6. 'Mouse Cursor' allows changing the mouse cursor appearance (system default or custom shapes).\n";
        std::cout << "7. 'File Operations' menu offers to Clear Screen, Save Drawing, and Load Drawing.\n";
        std::cout << "8. Keyboard Shortcuts: \n";
        std::cout << "   - Press 'C' or 'c' to clear the screen.\n";
        std::cout << "   - Press 'S' or 's' to save drawing data to 'drawing_data.txt'.\n";
        std::cout << "   - Press 'L' or 'l' to load drawing data from 'drawing_data.txt'.\n";
        std::cout << "   - Press 'ESC' key to exit the program.\n";
        std::cout << "-----------------------------------------------\n";

        SetMenu(pHwnd, CreateWin32Menu()); // Set the window's menu bar
        ShowCursor(FALSE); // Hide the system cursor initially if custom is enabled
        break;
    }

    case WM_SIZE:
        ReSizeGLScene(LOWORD(lParam), HIWORD(lParam)); // Resize the OpenGL viewport
        return 0;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        BeginPaint(pHwnd, &ps);
        DrawGLScene(); // Call our OpenGL drawing function
        EndPaint(pHwnd, &ps);
        return 0;
    }

    case WM_LBUTTONDOWN:
    {
        int x = GET_X_LPARAM(lParam);
        int y = windowHeight - GET_Y_LPARAM(lParam); // Invert y-coordinate

        MyPoint p_obj = { (float)x, (float)y }; // Using p_obj
        std::copy(currentColor, currentColor + 4, p_obj.color);

        if (floodFillActive) {
            float oldColor[4];
            getPixel(x, y, oldColor);
            if (!(fabs(oldColor[0] - currentColor[0]) < 0.01 &&
                fabs(oldColor[1] - currentColor[1]) < 0.01 &&
                fabs(oldColor[2] - currentColor[2]) < 0.01 &&
                fabs(oldColor[3] - oldColor[3]) < 0.01))
            {
                if (drawingMode == IDM_FLOOD_RECURSIVE) { // Reusing drawingMode for flood fill type
                    std::cout << "Starting recursive flood fill at (" << x << ", " << y << "). This might be slow for very large areas or complex shapes.\n";
                    floodFillRecursive(x, y, currentColor, oldColor);
                }
                else if (drawingMode == IDM_FLOOD_NONRECURSIVE) {
                    std::cout << "Starting non-recursive flood fill at (" << x << ", " << y << ").\n";
                    floodFillNonRecursive(x, y, currentColor, oldColor);
                }
                InvalidateRect(pHwnd, NULL, FALSE);
            }
            else {
                std::cout << "Area already filled with current color or color could not be read properly.\n";
            }
            floodFillActive = false; // Deactivate flood fill mode after click
            drawingMode = 0; // Reset drawing mode
            std::cout << "Flood fill operation complete.\n";
            // Optionally, revert the cursor if it was changed
            if (showCustomCursor) ShowCursor(FALSE);
            else ShowCursor(TRUE);
        }
        else { // Normal drawing modes
            if (drawingMode == IDM_SHAPE_POINT) {
                drawnPoints.push_back(p_obj); // Use p_obj
                std::cout << "Drew MyPoint at (" << x << ", " << y << ")\n";
            }
            else if (drawingMode == IDM_SHAPE_LINE) {
                tempPoints.push_back(p_obj); // Use p_obj
                if (tempPoints.size() == 2) {
                    MyLine l_obj = { tempPoints[0].x, tempPoints[0].y, tempPoints[1].x, tempPoints[1].y }; // Use MyLine
                    std::copy(currentColor, currentColor + 4, l_obj.color);
                    l_obj.algorithm = lineAlgorithm;
                    drawnLines.push_back(l_obj);
                    tempPoints.clear();
                    std::cout << "Drew MyLine from (" << l_obj.x0 << "," << l_obj.y0 << ") to (" << l_obj.x1 << "," << l_obj.y1 << ") using algorithm " << l_obj.algorithm << "\n";
                    drawingMode = 0;
                }
            }
            else if (drawingMode == IDM_SHAPE_CIRCLE) {
                tempPoints.push_back(p_obj); // Use p_obj
                if (tempPoints.size() == 2) {
                    int xc = round(tempPoints[0].x);
                    int yc = round(tempPoints[0].y);
                    int r = round(sqrt(pow(tempPoints[1].x - xc, 2) + pow(tempPoints[1].y - yc, 2)));
                    MyCircle c_obj = { (float)xc, (float)yc, (float)r }; // Use MyCircle
                    std::copy(currentColor, currentColor + 4, c_obj.color);
                    c_obj.algorithm = circleAlgorithm;
                    c_obj.fillMode = circleFillMode;
                    c_obj.fillQuarter = circleFillQuarter;
                    drawnCircles.push_back(c_obj);
                    tempPoints.clear();
                    std::cout << "Drew MyCircle at (" << xc << "," << yc << ") with radius " << r << " using algorithm " << c_obj.algorithm << "\n";
                    drawingMode = 0;
                }
            }
            else if (drawingMode == IDM_SHAPE_ELLIPSE) {
                tempPoints.push_back(p_obj); // Use p_obj
                if (tempPoints.size() == 3) {
                    int xc = round(tempPoints[0].x);
                    int yc = round(tempPoints[0].y);
                    int rx = abs(round(tempPoints[1].x - xc));
                    int ry = abs(round(tempPoints[2].y - yc));
                    MyEllipse e_obj = { (float)xc, (float)yc, (float)rx, (float)ry };
                    std::copy(currentColor, currentColor + 4, e_obj.color);
                    drawnEllipses.push_back(e_obj);
                    tempPoints.clear();
                    std::cout << "Drew MyEllipse at (" << xc << "," << yc << ") with rx=" << rx << ", ry=" << ry << " using algorithm " << e_obj.algorithm << "\n";
                    drawingMode = 0;
                }
            }
            else if (drawingMode == IDM_SHAPE_POLYGON || drawingMode == IDM_SHAPE_CARDINAL || drawingMode == IDM_SHAPE_BEZIER) {
                tempPoints.push_back(p_obj); // Use p_obj
                if (drawingMode == IDM_SHAPE_POLYGON) {
                    std::cout << "Added vertex for MyPolygon: (" << x << ", " << y << "). Right-click to finish.\n";
                }
                else if (drawingMode == IDM_SHAPE_CARDINAL) {
                    std::cout << "Added control point for Cardinal Spline: (" << x << ", " << y << "). Need at least 4. Right-click to finish.\n";
                }
                else if (drawingMode == IDM_SHAPE_BEZIER) {
                    if (tempPoints.size() == 4) {
                        MyCurve c_obj = { tempPoints, {0,0,0,1}, 1 }; // Use MyCurve
                        std::copy(currentColor, currentColor + 4, c_obj.color);
                        drawnCurves.push_back(c_obj);
                        tempPoints.clear();
                        std::cout << "Drew MyBezier Curve with 4 control points.\n";
                        drawingMode = 0;
                    }
                    else {
                        std::cout << "Added control point for MyBezier Curve: (" << x << ", " << y << "). Need " << (4 - tempPoints.size()) << " more.\n";
                    }
                }
            }
        }
        InvalidateRect(pHwnd, NULL, FALSE); // Redraw the window
        return 0;
    }

    case WM_RBUTTONDOWN:
    {
        // Finish polygon or spline if in progress
        if (drawingMode == IDM_SHAPE_POLYGON && tempPoints.size() >= 3) {
            MyPolygon poly_obj; // Use MyPolygon
            poly_obj.vertices = tempPoints;
            std::copy(currentColor, currentColor + 4, poly_obj.color);
            drawnPolygons.push_back(poly_obj);
            tempPoints.clear();
            drawingMode = 0;
            std::cout << "Finished drawing MyPolygon with " << poly_obj.vertices.size() << " vertices.\n";
            InvalidateRect(pHwnd, NULL, FALSE);
        }
        else if (drawingMode == IDM_SHAPE_CARDINAL && tempPoints.size() >= 4) {
            MyCurve c_obj = { tempPoints, {0,0,0,1}, 0 }; // Use MyCurve
            std::copy(currentColor, currentColor + 4, c_obj.color);
            drawnCurves.push_back(c_obj);
            tempPoints.clear();
            drawingMode = 0;
            std::cout << "Finished drawing Cardinal Spline with " << c_obj.controlPoints.size() << " control points.\n";
            InvalidateRect(pHwnd, NULL, FALSE);
        }
        else if (drawingMode == IDM_SHAPE_BEZIER && tempPoints.size() < 4 && tempPoints.size() > 0) {
            std::cout << "Cancelled MyBezier curve drawing (not enough points).\n";
            tempPoints.clear();
            drawingMode = 0;
            InvalidateRect(pHwnd, NULL, FALSE);
        }
        // If not handling a drawing completion, let the system handle context menu if any.
        return 0;
    }

    case WM_MOUSEMOVE:
    {
        mouseX = GET_X_LPARAM(lParam);
        mouseY = windowHeight - GET_Y_LPARAM(lParam); // Invert y-coordinate
        InvalidateRect(pHwnd, NULL, FALSE); // Trigger redraw for cursor
        return 0;
    }

    case WM_KEYDOWN:
    {
        switch (wParam) {
        case VK_ESCAPE: // ESC key
            PostQuitMessage(0); // Terminate the application
            return 0;
        case 'C': // 'C' key
            drawnPoints.clear();
            drawnLines.clear();
            drawnCircles.clear();
            drawnEllipses.clear();
            drawnPolygons.clear();
            drawnCurves.clear();
            tempPoints.clear();
            drawingMode = 0;
            floodFillActive = false;
            std::cout << "Screen cleared.\n";
            InvalidateRect(pHwnd, NULL, FALSE);
            return 0;
        case 'S': // 'S' key
            saveData("drawing_data.txt");
            return 0;
        case 'L': // 'L' key
            loadData("drawing_data.txt");
            return 0;
        }
        return 0;
    }

    case WM_COMMAND:
    {
        int wmId = LOWORD(wParam);
        // Parse the menu item selected
        switch (wmId) {
        case IDM_EXIT:
            PostQuitMessage(0);
            break;

            // Color Menu
        case IDM_COLOR_RED: std::copy(std::vector<float>{1.0f, 0.0f, 0.0f, 1.0f}.begin(), std::vector<float>{1.0f, 0.0f, 0.0f, 1.0f}.end(), currentColor); std::cout << "Color: Red\n"; break;
        case IDM_COLOR_GREEN: std::copy(std::vector<float>{0.0f, 1.0f, 0.0f, 1.0f}.begin(), std::vector<float>{0.0f, 1.0f, 0.0f, 1.0f}.end(), currentColor); std::cout << "Color: Green\n"; break;
        case IDM_COLOR_BLUE: std::copy(std::vector<float>{0.0f, 0.0f, 1.0f, 1.0f}.begin(), std::vector<float>{0.0f, 0.0f, 1.0f, 1.0f}.end(), currentColor); std::cout << "Color: Blue\n"; break;
        case IDM_COLOR_BLACK: std::copy(std::vector<float>{0.0f, 0.0f, 0.0f, 1.0f}.begin(), std::vector<float>{0.0f, 0.0f, 0.0f, 1.0f}.end(), currentColor); std::cout << "Color: Black\n"; break;
        case IDM_COLOR_WHITE: std::copy(std::vector<float>{1.0f, 1.0f, 1.0f, 1.0f}.begin(), std::vector<float>{1.0f, 1.0f, 1.0f, 1.0f}.end(), currentColor); std::cout << "Color: White\n"; break;
        case IDM_COLOR_YELLOW: std::copy(std::vector<float>{1.0f, 1.0f, 0.0f, 1.0f}.begin(), std::vector<float>{1.0f, 1.0f, 0.0f, 1.0f}.end(), currentColor); std::cout << "Color: Yellow\n"; break;
        case IDM_COLOR_CYAN: std::copy(std::vector<float>{0.0f, 1.0f, 1.0f, 1.0f}.begin(), std::vector<float>{0.0f, 1.0f, 1.0f, 1.0f}.end(), currentColor); std::cout << "Color: Cyan\n"; break;
        case IDM_COLOR_MAGENTA: std::copy(std::vector<float>{1.0f, 0.0f, 1.0f, 1.0f}.begin(), std::vector<float>{1.0f, 0.0f, 1.0f, 1.0f}.end(), currentColor); std::cout << "Color: Magenta\n"; break;

            // Shape Menu
        case IDM_SHAPE_POINT: drawingMode = IDM_SHAPE_POINT; tempPoints.clear(); std::cout << "Mode: MyPoint\n"; break;
        case IDM_SHAPE_LINE: drawingMode = IDM_SHAPE_LINE; tempPoints.clear(); std::cout << "Mode: MyLine\n"; break;
        case IDM_SHAPE_CIRCLE: drawingMode = IDM_SHAPE_CIRCLE; tempPoints.clear(); std::cout << "Mode: MyCircle\n"; break;
        case IDM_SHAPE_ELLIPSE: drawingMode = IDM_SHAPE_ELLIPSE; tempPoints.clear(); std::cout << "Mode: MyEllipse\n"; break;
        case IDM_SHAPE_POLYGON: drawingMode = IDM_SHAPE_POLYGON; tempPoints.clear(); std::cout << "Mode: MyPolygon. Right-click to finish.\n"; break;
        case IDM_SHAPE_CARDINAL: drawingMode = IDM_SHAPE_CARDINAL; tempPoints.clear(); std::cout << "Mode: Cardinal Spline. Need >=4 points. Right-click to finish.\n"; break;
        case IDM_SHAPE_BEZIER: drawingMode = IDM_SHAPE_BEZIER; tempPoints.clear(); std::cout << "Mode: MyBezier Curve. Need exactly 4 points.\n"; break;

            // Line Algorithms
        case IDM_LINE_DDA: lineAlgorithm = 0; std::cout << "Line Algo: DDA\n"; drawingMode = IDM_SHAPE_LINE; break;
        case IDM_LINE_MIDPOINT: lineAlgorithm = 1; std::cout << "Line Algo: Midpoint\n"; drawingMode = IDM_SHAPE_LINE; break;
        case IDM_LINE_PARAMETRIC: lineAlgorithm = 2; std::cout << "Line Algo: Parametric\n"; drawingMode = IDM_SHAPE_LINE; break;

            // Circle Algorithms
        case IDM_CIRCLE_DIRECT: circleAlgorithm = 0; std::cout << "Circle Algo: Direct\n"; drawingMode = IDM_SHAPE_CIRCLE; break;
        case IDM_CIRCLE_POLAR: circleAlgorithm = 1; std::cout << "Circle Algo: Polar\n"; drawingMode = IDM_SHAPE_CIRCLE; break;
        case IDM_CIRCLE_ITERATIVE: circleAlgorithm = 2; std::cout << "Circle Algo: Iterative Polar\n"; drawingMode = IDM_SHAPE_CIRCLE; break;
        case IDM_CIRCLE_MIDPOINT: circleAlgorithm = 3; std::cout << "Circle Algo: Midpoint\n"; drawingMode = IDM_SHAPE_CIRCLE; break;
        case IDM_CIRCLE_MODIFIED: circleAlgorithm = 4; std::cout << "Circle Algo: Modified Midpoint\n"; drawingMode = IDM_SHAPE_CIRCLE; break;

            // Ellipse Algorithms
        case IDM_ELLIPSE_DIRECT: ellipseAlgorithm = 0; std::cout << "Ellipse Algo: Direct\n"; drawingMode = IDM_SHAPE_ELLIPSE; break;
        case IDM_ELLIPSE_POLAR: ellipseAlgorithm = 1; std::cout << "Ellipse Algo: Polar\n"; drawingMode = IDM_SHAPE_ELLIPSE; break;
        case IDM_ELLIPSE_MIDPOINT: ellipseAlgorithm = 2; std::cout << "Ellipse Algo: Midpoint\n"; drawingMode = IDM_SHAPE_ELLIPSE; break;

            // Circle Fill
        case IDM_FILL_CIRCLE_Q1: circleFillMode = 1; circleFillQuarter = 1; std::cout << "Circle Fill: Q1 Lines. Draw new circle.\n"; break;
        case IDM_FILL_CIRCLE_Q2: circleFillMode = 1; circleFillQuarter = 2; std::cout << "Circle Fill: Q2 Lines. Draw new circle.\n"; break;
        case IDM_FILL_CIRCLE_Q3: circleFillMode = 1; circleFillQuarter = 3; std::cout << "Circle Fill: Q3 Lines. Draw new circle.\n"; break;
        case IDM_FILL_CIRCLE_Q4: circleFillMode = 1; circleFillQuarter = 4; std::cout << "Circle Fill: Q4 Lines. Draw new circle.\n"; break;
        case IDM_FILL_CIRCLE_LINES: circleFillMode = 1; circleFillQuarter = 0; std::cout << "Circle Fill: Whole Lines. Draw new circle.\n"; break;
        case IDM_FILL_CIRCLE_CIRCLES: circleFillMode = 2; circleFillQuarter = 0; std::cout << "Circle Fill: Whole Circles. Draw new circle.\n"; break;
        case IDM_FILL_CIRCLE_NONE: circleFillMode = 0; circleFillQuarter = 0; std::cout << "Circle Fill: None. Draw new circle.\n"; break;

            // Other Fill (Conceptual)
        case IDM_FILL_SQUARE: std::cout << "Fill Square (Hermite - Conceptual): Draw polygon, then cardinal spline.\n"; break;
        case IDM_FILL_RECTANGLE: std::cout << "Fill Rectangle (Bezier - Conceptual): Draw polygon, then bezier curve.\n"; break;

            // Polygon Fill
        case IDM_POLYGON_CONVEX: std::cout << "Polygon Fill: Convex selected. Draw polygon.\n"; break;
        case IDM_POLYGON_NONCONVEX: std::cout << "Polygon Fill: Non-Convex selected. Draw polygon.\n"; break;

            // Flood Fill
        case IDM_FLOOD_RECURSIVE:
            floodFillActive = true;
            drawingMode = IDM_FLOOD_RECURSIVE; // Use drawingMode to store flood fill type
            std::cout << "Recursive Flood Fill active. Click on an area to fill.\n";
            ShowCursor(TRUE); // Ensure system cursor is visible for flood fill
            break;
        case IDM_FLOOD_NONRECURSIVE:
            floodFillActive = true;
            drawingMode = IDM_FLOOD_NONRECURSIVE; // Use drawingMode to store flood fill type
            std::cout << "Non-Recursive Flood Fill active. Click on an area to fill.\n";
            ShowCursor(TRUE);
            break;

            // Clipping
        case IDM_CLIP_ENABLE: clippingEnabled = true; std::cout << "Clipping Enabled. Red window.\n"; break;
        case IDM_CLIP_DISABLE: clippingEnabled = false; std::cout << "Clipping Disabled.\n"; break;
        case IDM_CLIP_SETWINDOW:
            std::cout << "Clipping window coordinates are fixed: (" << clipWindowMinX << ", " << clipWindowMinY << ") to ("
                << clipWindowMaxX << ", " << clipWindowMaxY << ")\n";
            break;
        case IDM_CLIP_TYPE_POINT: clippingType = 0; std::cout << "Clipping Type: MyPoint.\n"; break;
        case IDM_CLIP_TYPE_LINE: clippingType = 1; std::cout << "Clipping Type: MyLine.\n"; break;
        case IDM_CLIP_TYPE_POLYGON: clippingType = 2; std::cout << "Clipping Type: MyPolygon.\n"; break;
        case IDM_CLIP_WINDOW_RECTANGLE:
            clippingWindowShape = 0;
            clipWindowMinX = 200; clipWindowMinY = 200;
            clipWindowMaxX = 600; clipWindowMaxY = 400;
            std::cout << "Clipping Window: Rectangle.\n";
            break;
        case IDM_CLIP_WINDOW_SQUARE:
        { // Added scope block to prevent "initialization is skipped" error
            clippingWindowShape = 1;
            clipWindowMinX = 200; clipWindowMinY = 200;
            clipWindowMaxX = 600;
            float side = clipWindowMaxX - clipWindowMinX;
            clipWindowMaxY = clipWindowMinY + side;
            std::cout << "Clipping Window: Square.\n";
        }
        break;

        // Cursor
        case IDM_CURSOR_DEFAULT: showCustomCursor = false; ShowCursor(TRUE); std::cout << "Cursor: System Default.\n"; break;
        case IDM_CURSOR_SQUARE: customCursorShape = 0; showCustomCursor = true; ShowCursor(FALSE); std::cout << "Cursor: Custom Square.\n"; break;
        case IDM_CURSOR_CROSS: customCursorShape = 1; showCustomCursor = true; ShowCursor(FALSE); std::cout << "Cursor: Custom Cross.\n"; break;
        case IDM_CURSOR_CIRCLE: customCursorShape = 2; showCustomCursor = true; ShowCursor(FALSE); std::cout << "Cursor: Custom Circle.\n"; break;

            // File Operations
        case IDM_FILE_CLEAR:
            drawnPoints.clear(); drawnLines.clear(); drawnCircles.clear(); drawnEllipses.clear();
            drawnPolygons.clear(); drawnCurves.clear(); tempPoints.clear(); drawingMode = 0; floodFillActive = false;
            std::cout << "Screen cleared.\n";
            break;
        case IDM_FILE_SAVE: saveData("drawing_data.txt"); break;
        case IDM_FILE_LOAD: loadData("drawing_data.txt"); break;
        }
        InvalidateRect(pHwnd, NULL, FALSE); // Request redraw after menu action
        break;
    }

    case WM_CLOSE: // Window is being closed
        // Cleanup OpenGL rendering context and device context
        if (hRC) {
            wglMakeCurrent(NULL, NULL);
            wglDeleteContext(hRC);
            hRC = NULL;
        }
        if (hDC) {
            ReleaseDC(pHwnd, hDC);
            hDC = NULL;
        }
        DestroyWindow(pHwnd); // Destroy the window
        return 0;

    case WM_DESTROY: // Window has been destroyed
        PostQuitMessage(0); // Post a WM_QUIT message to terminate the message loop
        return 0;
    }

    return DefWindowProc(pHwnd, uMsg, wParam, lParam); // Default message processing
}

// --- WinMain (Entry point for Windows applications) ---
int WINAPI WinMain(HINSTANCE hInstanceIn, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    WNDCLASS wc;
    LPCTSTR szWindowClass = TEXT("OpenGLWin32Drawing");
    LPCTSTR szTitle = TEXT("Computer Graphics Drawing Program (Win32)");

    hInstance = hInstanceIn; // Store instance handle for menu creation

    // Register Window Class
    wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC; // Redraw on size, get own DC
    wc.lpfnWndProc = WndProc;                      // Window procedure
    wc.cbClsExtra = 0;                             // No extra class data
    wc.cbWndExtra = 0;                             // No extra window data
    wc.hInstance = hInstanceIn;                    // Current instance
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);    // Default icon
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);      // Default arrow cursor
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); // Black background initially, OpenGL clears to white
    wc.lpszMenuName = NULL;                        // No default menu from resource
    wc.lpszClassName = szWindowClass;              // Class name

    if (!RegisterClass(&wc)) {
        MessageBox(NULL, TEXT("Window Registration Failed!"), TEXT("Error"), MB_ICONERROR | MB_OK);
        return 0;
    }

    // Create Window
    hWnd = CreateWindowEx(
        WS_EX_APPWINDOW,                     // Extended style
        szWindowClass,                       // Class name
        szTitle,                             // Window title
        WS_OVERLAPPEDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, // Window style
        CW_USEDEFAULT, CW_USEDEFAULT,        // Default X, Y
        windowWidth, windowHeight,           // Width, Height
        NULL,                                // Parent window
        NULL,                                // Menu (will be set dynamically)
        hInstanceIn,                         // Instance handle
        NULL                                 // Creation parameters
    );

    if (!hWnd) {
        MessageBox(NULL, TEXT("Window Creation Failed!"), TEXT("Error"), MB_ICONERROR | MB_OK);
        return 0;
    }

    ShowWindow(hWnd, nCmdShow); // Show the window
    UpdateWindow(hWnd);         // Paint the window

    // Message Loop
    MSG msg;
    BOOL bDone = FALSE;

    while (!bDone) {
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) { // Is there a message waiting?
            if (msg.message == WM_QUIT) { // Has a quit message been received?
                bDone = TRUE; // If so, Terminate The Loop
            }
            else {
                TranslateMessage(&msg); // Translate The Message
                DispatchMessage(&msg);  // Dispatch The Message
            }
        }
        else { // If there are no messages to process, draw the scene
            DrawGLScene();
        }
    }

    return (int)msg.wParam; // Return Exit Code
}
